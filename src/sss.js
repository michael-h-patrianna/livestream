!function (e, t) { "object" == typeof exports && "object" == typeof module ? module.exports = t() : "function" == typeof define && define.amd ? define([], t) : "object" == typeof exports ? exports.livespins = t() : e.livespins = t() }(self, (() => (() => { var e = { 8550: (e, t, r) => { "use strict"; r.r(t), r.d(t, { default: () => n }); const n = '<style>:host{--cta-button-background:white;--cta-button-background-active:#efefef;--cta-action-color:white;--cta-variable-text-color:white;--card-width:344px;--cta-text-color:#01062b}.container .badge.test{display:none}.container.isTesting .badge.test{display:block}.container{display:flex;flex-direction:column;overflow:hidden}.noselect{-webkit-touch-callout:none;-webkit-user-select:none;-khtml-user-select:none;-moz-user-select:none;-ms-user-select:none;user-select:none}.clickable{cursor:pointer}.ratio169{aspect-ratio:16/9;height:100%;width:100%}.ratio169::before{float:left;padding-top:56.25%;content:\'\'}.ratio169::after{display:block;content:\'\';clear:both}.clamp-width{width:max(var(--card-width),344px)}.wrapper{color:#fff;position:relative}.layer{position:absolute;top:0;bottom:0;left:0;right:0;border-radius:8px;overflow:hidden;display:flex;transition:opacity .3s ease-out;transform:translate3d(0,0,0)}.layer.inner{padding:8px}.blur{background:rgba(13,13,16,.2);backdrop-filter:blur(20px);-webkit-backdrop-filter:blur(20px)}.small-view .badge{padding:2px 6px}.badge{border-radius:4px;padding:4px 8px;margin-right:4px;display:flex;align-self:flex-start}.badge.live{background:#ff005c;box-shadow:0 2px 0 rgba(0,0,0,.2)}.badge.test{background:#f2d016;box-shadow:0 2px 0 rgba(0,0,0,.2)}.badge.live .text.stroke,.badge.test .text.stroke{text-shadow:-.8px .8px 0 #000,-.8px -.8px 0 #000,.8px -.8px 0 #000,.8px .8px 0 #000,-.4px 1.8px 0 #000,-.2px 1.8px 0 #000,0 1.8px 0 #000,.2px 1.8px 0 #000,.4px 1.8px 0 #000,.8px 1.8px 0 #000}.badge.live .text,.badge.test .text{text-transform:uppercase}.text-italic{font-style:italic}.badge .icon{padding-right:4px;display:flex;align-items:center}.object-fit--cover{object-fit:cover}.placeholder-streamer img{height:100%;object-fit:cover;margin-right:-32px;margin-left:auto}.livespins-footer-logo,.stream-event-image-placeholder,.stream-name-image-placeholder,.streaming-image-placeholder{height:100%;object-fit:cover;margin-left:auto}.layer.placeholder-streamer{justify-content:end}.small-view .header{font-size:10px;line-height:12px}.header{font-size:12px;line-height:14px;font-family:Arial,Helvetica,sans-serif;color:#fff;font-weight:700}.event-overlay-tint{opacity:.8}.backdrop-1 .overlay-tint{background:linear-gradient(237.81deg,rgba(42,29,91,0) 30.68%,#b55591 100%);opacity:.4}.backdrop-2 .overlay-tint{background:linear-gradient(237.81deg,rgba(42,29,91,0) 30.68%,#3cb5a1 100%);opacity:.4}.backdrop-3 .overlay-tint{background:linear-gradient(237.81deg,rgba(42,29,91,0) 30.68%,#599ce3 100%);opacity:.4}.backdrop-4 .overlay-tint{background:linear-gradient(237.81deg,rgba(42,29,91,0) 30.68%,#8e63e7 100%);opacity:.4}.backdrop-1 .base-tint{background:linear-gradient(240.83deg,#ff005c -30.67%,#4e4ef2 100%);opacity:.2}.backdrop-2 .base-tint{background:linear-gradient(240.83deg,#30ed7b -30.67%,#4e4ef2 100%);opacity:.2}.backdrop-3 .base-tint{background:linear-gradient(240.83deg,#60a8ff -30.67%,#4e4ef2 100%);opacity:.2}.backdrop-4 .base-tint{background:linear-gradient(240.83deg,#9c6dff -30.67%,#4e4ef2 100%);opacity:.2}.backdrop-1 .base-backdrop{background:linear-gradient(146.31deg,#ff4739 -15%,#a04ef2 115%)}.backdrop-2 .base-backdrop{background:linear-gradient(146.31deg,#1ee46c -15%,#0096c6 115%)}.backdrop-3 .base-backdrop{background:linear-gradient(146.31deg,#61e9ce -15%,#4e4ef2 115%)}.backdrop-4 .base-backdrop{background:linear-gradient(137.59deg,#9c6dff 0,#4545f0 104.95%)}.backdrop-1 .streaming{color:#cd427e}.backdrop-2 .streaming{color:#1ebc91}.backdrop-3 .streaming{color:#5a9ee4}.backdrop-4 .streaming{color:#8261f6}.cta-container{padding-top:8px;display:flex;flex-direction:row;align-items:center;white-space:nowrap;color:var(--cta-text-color);font-family:Arial,Helvetica,sans-serif}.cta-container,.cta-container .cta-button{font-size:14px;line-height:16px}.small-view .cta-container,.small-view .cta-container .cta-button{font-size:12px;line-height:16px}.cta-container .cta-button{border:0;display:flex;flex-direction:row;align-items:center;padding:8px 16px;background:var(--cta-button-background);border-radius:32px;font-weight:700;color:inherit}.small-view .cta-container .cta-button{padding:4px 8px}.cta-container .cta-button:active{background:var(--cta-button-background-active)}.cta-container .cta-info{padding-left:12px;overflow:hidden;text-overflow:ellipsis}.small-view .cta-container .cta-info{padding-left:8px}.cta-container .cta-action{color:var(--cta-action-color)}.cta-container .cta-variable-text{color:var(--cta-variable-text-color)}.layer.hide{opacity:0}.display-none{display:none}.small-view .footer{flex-direction:column;padding:18% 16px 16px 16px}.footer{flex-direction:column;padding:12% 24px 16px 24px}.text.stroke{text-shadow:-.8px .8px 0 #000,-1px 1px 0 #000,-1.2px 1.2px 0 #000,-.8px -.8px 0 #000,-1px -1px 0 #000,-1.2px -1.2px 0 #000,.8px -.8px 0 #000,1px -1px 0 #000,1.8px -1.8px 0 #000,.8px .8px 0 #000,1px 1px 0 #000,1.8px 1.8px 0 #000,-.4px 1.8px 0 #000,-.2px 1.8px 0 #000,0 1.8px 0 #000,.2px 1.8px 0 #000,.4px 1.8px 0 #000,.8px 1.8px 0 #000,0 8px 4px rgba(0,0,0,.2)}.footer .info-text{flex:1;font-family:Verdana,Geneva,Tahoma,sans-serif;font-weight:900}.livespins-logo{opacity:.2}.info-text .streaming{font-size:12px;line-height:24px}.small-view .info-text .streaming{font-size:8px;line-height:12px}.info-text .streamer-name{width:max(70%,200px);font-size:32px;line-height:34px;word-break:break-word;letter-spacing:-2px;padding-top:32px}.small-view .info-text .streamer-name{width:100%;font-size:18px;line-height:20px}</style> <div class="container clamp-width"> <div class="wrapper ratio169 noselect"> <div class="layer"> <img data-target="stream-thumbnail" class="ratio169 object-fit--cover" alt="Stream thumbnail"/> </div> <div class="layer base-backdrop" data-target="layer-placeholder"></div> <div class="layer base-pattern" data-target="layer-placeholder"> <svg xmlns="http://www.w3.org/2000/svg" width="100%" height="100%" fill="none" preserveAspectRatio="none" viewBox="0 0 344 193"> <path fill="#23272A" fill-rule="evenodd" d="M146.632 194h142.662L311.655 0h-87.024l-70.62 27.7611L153.415 0H0v194h96.8264l52.2136-20.488L146.632 194Z" clip-rule="evenodd"/> </svg> </div> <div class="layer hide" data-target="pattern-layer"> <img class="ratio169" src="https://assets.livespins.com/room-events/raw/dotted-full.png" alt="Pattern background image"/> </div> <div class="layer"> <img class="livespins-footer-logo" src="https://assets.livespins.com/streamers/livespins-footer-logo.png" alt="Livespins Logo"/> </div> <div class="layer base-tint" data-target="layer-placeholder"></div> <div class="layer" data-target="layer-placeholder"> <img class="ratio169" src="https://assets.livespins.com/room-events/raw/dotted.png" alt="Pattern background image"/> </div> <div class="layer placeholder-streamer" data-target="streamer-placeholder"> <img data-target="streamer-image-placeholder" src="https://assets.livespins.com/room-events/raw/default-1.png" alt="Streamer placeholder image"/> </div> <div class="layer overlay-tint"></div> <div class="layer event-overlay-tint hide"></div> <div class="layer hide" data-target="layer-events"> <img data-target="stream-event-image-placeholder" class="stream-event-image-placeholder" src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAQAAAC1HAwCAAAAC0lEQVR42mNkYAAAAAYAAjCB0C8AAAAASUVORK5CYII=" alt="Streamer event placeholder image"/> </div> <div class="layer inner header"> <div class="badge live"> <div class="text stroke text-italic" data-i18n="live"></div> </div> <div class="badge test"> <div class="text stroke text-italic">Test</div> </div> <div class="badge blur" data-target="viewers-badge"> <span class="icon"><svg xmlns="http://www.w3.org/2000/svg" fill="none" width="14" height="10" viewBox="0 0 14 10"> <path fill="#fff" d="M7.0002.625C4.0835.625 1.5927 2.4392.5835 5c1.0092 2.5608 3.5 4.375 6.4167 4.375 2.9166 0 5.4075-1.8142 6.4166-4.375-1.0091-2.5608-3.5-4.375-6.4166-4.375Zm0 7.2917C5.3902 7.9167 4.0835 6.61 4.0835 5s1.3067-2.9167 2.9167-2.9167S9.9168 3.39 9.9168 5 8.6102 7.9167 7.0002 7.9167Zm0-4.6667c-.9684 0-1.75.7817-1.75 1.75s.7816 1.75 1.75 1.75c.9683 0 1.75-.7817 1.75-1.75s-.7817-1.75-1.75-1.75Z"/> </svg> </span> <span data-bind="viewers">0</span> </div> <div class="badge blur" data-bind="language"></div> </div> <div class="layer footer hide"> <div class="info-text text-italic text stroke"> <div class="streamer-name" data-bind="streamernickname"></div> </div> </div> <div class="layer streaming-image-content"> <img data-target="streaming-image-placeholder" class="streaming-image-placeholder" src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAQAAAC1HAwCAAAAC0lEQVR42mNkYAAAAAYAAjCB0C8AAAAASUVORK5CYII=" alt="Streaming"/> </div> <div class="layer streaming-image-content"> <img data-target="streamer-name-image-placeholder" class="stream-name-image-placeholder" src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAQAAAC1HAwCAAAAC0lEQVR42mNkYAAAAAYAAjCB0C8AAAAASUVORK5CYII=" alt="Streamer name image"/> </div> </div> <div class="cta-container display-none clickable"> <button class="cta-button clickable" data-i18n="play_now"></button> <div class="cta-info"> <span class="cta-action" data-i18n="playing"></span> <span class="cta-variable-text"><strong data-bind="currentgametitle"></strong></span> </div> </div> </div> ' }, 7618: (e, t, r) => { "use strict"; r.r(t), r.d(t, { default: () => n }); const n = '<style>:host{--time-background:#202027;--card-width:344px;--cta-action-color:rgba(255, 255, 255, 0.5);--cta-variable-text-color:#dfdfdf}.container{display:flex;flex-direction:column;overflow:hidden}.noselect{-webkit-touch-callout:none;-webkit-user-select:none;-khtml-user-select:none;-moz-user-select:none;-ms-user-select:none;user-select:none}.ratio169{aspect-ratio:16/9;height:100%;width:100%}.ratio169::before{float:left;padding-top:56.25%;content:\'\'}.ratio169::after{display:block;content:\'\';clear:both}.clamp-width{width:max(var(--card-width),344px)}.wrapper{color:#fff;position:relative}.layer{position:absolute;top:0;bottom:0;left:0;right:0;border-radius:8px;display:flex;overflow:hidden;transition:opacity .3s ease-out;transform:translate3d(0,0,0)}.layer.inner{padding:8px}.blur{background:rgba(13,13,16,.2);backdrop-filter:blur(20px);-webkit-backdrop-filter:blur(20px)}.small-view .badge{padding:2px 6px}.badge{border-radius:4px;padding:4px 8px;margin-right:4px;display:flex;align-self:flex-start}.badge.later{background:#18181d;text-transform:uppercase;box-shadow:0 2px 0 rgba(0,0,0,.1)}.badge.later .text{text-transform:uppercase}.text-italic{font-style:italic}.badge .icon{padding-right:4px;display:flex;align-items:center}.placeholder-streamer img{height:100%;object-fit:cover;margin-right:-32px;margin-left:auto}.livespins-footer-logo,.stream-event-image-placeholder,.stream-name-image-placeholder,.streaming-image-placeholder{height:100%;object-fit:cover;margin-left:auto}.layer.placeholder-streamer{justify-content:end}.small-view .header{font-size:10px;line-height:12px}.header{font-size:12px;line-height:14px;font-family:Arial,Helvetica,sans-serif;color:#fff;font-weight:700}.footer{flex-direction:column;padding:12% 24px 16px 24px}.text.stroke{text-shadow:-.8px .8px 0 #000,-1px 1px 0 #000,-1.2px 1.2px 0 #000,-.8px -.8px 0 #000,-1px -1px 0 #000,-1.2px -1.2px 0 #000,.8px -.8px 0 #000,1px -1px 0 #000,1.8px -1.8px 0 #000,.8px .8px 0 #000,1px 1px 0 #000,1.8px 1.8px 0 #000,-.4px 1.8px 0 #000,-.2px 1.8px 0 #000,0 1.8px 0 #000,.2px 1.8px 0 #000,.4px 1.8px 0 #000,.8px 1.8px 0 #000,0 8px 4px rgba(0,0,0,.2)}.footer .info-text{flex:1;font-family:Verdana,Geneva,Tahoma,sans-serif;font-weight:900}.info-text .streaming{font-size:12px;line-height:24px}.info-text .streamer-name{width:max(70%,200px);font-size:32px;line-height:34px;word-break:break-word;letter-spacing:-2px}.overlay-tint{background:linear-gradient(237.81deg,rgba(42,29,91,0) 30.68%,#4e4ef2 100%);opacity:.5}.layer.hide{opacity:0}.display-none{display:none}.backdrop-1 .overlay-tint{background:linear-gradient(237.81deg,rgba(42,29,91,0) 30.68%,#b55591 100%);opacity:.4}.backdrop-2 .overlay-tint{background:linear-gradient(237.81deg,rgba(42,29,91,0) 30.68%,#3cb5a1 100%);opacity:.4}.backdrop-3 .overlay-tint{background:linear-gradient(237.81deg,rgba(42,29,91,0) 30.68%,#599ce3 100%);opacity:.4}.backdrop-4 .overlay-tint{background:linear-gradient(237.81deg,rgba(42,29,91,0) 30.68%,#8e63e7 100%);opacity:.4}.backdrop-1 .base-tint{background:linear-gradient(240.83deg,#ff005c -30.67%,#4e4ef2 100%);opacity:.2}.backdrop-2 .base-tint{background:linear-gradient(240.83deg,#30ed7b -30.67%,#4e4ef2 100%);opacity:.2}.backdrop-3 .base-tint{background:linear-gradient(240.83deg,#60a8ff -30.67%,#4e4ef2 100%);opacity:.2}.backdrop-4 .base-tint{background:linear-gradient(240.83deg,#9c6dff -30.67%,#4e4ef2 100%);opacity:.2}.backdrop-1 .base-backdrop{background:linear-gradient(146.31deg,#ff4739 -15%,#a04ef2 115%)}.backdrop-2 .base-backdrop{background:linear-gradient(146.31deg,#1ee46c -15%,#0096c6 115%)}.backdrop-3 .base-backdrop{background:linear-gradient(146.31deg,#61e9ce -15%,#4e4ef2 115%)}.backdrop-4 .base-backdrop{background:linear-gradient(137.59deg,#9c6dff 0,#4545f0 104.95%)}.backdrop-1 .streaming{color:#cd427e}.backdrop-2 .streaming{color:#1ebc91}.backdrop-3 .streaming{color:#5a9ee4}.backdrop-4 .streaming{color:#8261f6}.livespins-logo{opacity:.2}.cta-container{padding-top:8px;display:flex;flex-direction:row;align-items:center;white-space:nowrap;color:#01062b;font-family:Arial,Helvetica,sans-serif;font-size:14px;line-height:16px}.small-view .cta-container,.small-view .cta-container .cta-button{font-size:12px;line-height:16px}.cta-container.display-none{display:none}.cta-container .time-background{background:var(--time-background);padding:6px;margin-right:8px;border-radius:100%;display:flex}.small-view .cta-container .time-background{padding:2px}.cta-container .cta-action{color:var(--cta-action-color)}.cta-container .cta-variable-text{color:var(--cta-variable-text-color)}</style> <div class="container clamp-width"> <div class="wrapper ratio169 noselect"> <div class="layer base-backdrop"></div> <div class="layer base-pattern"> <svg xmlns="http://www.w3.org/2000/svg" width="100%" height="100%" fill="none" preserveAspectRatio="none" viewBox="0 0 344 193"> <path fill="#23272A" fill-rule="evenodd" d="M146.632 194h142.662L311.655 0h-87.024l-70.62 27.7611L153.415 0H0v194h96.8264l52.2136-20.488L146.632 194Z" clip-rule="evenodd"/> </svg> </div> <div class="layer"> <img class="ratio169" src="https://assets.livespins.com/room-events/raw/dotted.png" alt="Pattern background image"/> </div> <div class="layer"> <img class="livespins-footer-logo" src="https://assets.livespins.com/streamers/livespins-footer-logo.png" alt="Livespins Logo"/> </div> <div class="layer base-tint"></div> <div class="layer placeholder-streamer"> <img data-target="streamer-image-placeholder" src="https://assets.livespins.com/room-events/raw/default-1.png" alt="Streamer placeholder image"/> </div> <div class="layer overlay-tint"></div> <div class="layer hide" data-target="layer-events"> <img data-target="stream-event-image-placeholder" class="stream-event-image-placeholder" src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAQAAAC1HAwCAAAAC0lEQVR42mNkYAAAAAYAAjCB0C8AAAAASUVORK5CYII=" alt="Streamer event placeholder image"/> </div> <div class="layer inner header"> <div class="badge later"> <div class="text text-italic" data-target="next-up-badge-text" data-i18n="later"></div> </div> <div class="badge blur" data-bind="language"></div> </div> <div class="layer streaming-image-content"> <img data-target="streaming-image-placeholder" class="streaming-image-placeholder" src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAQAAAC1HAwCAAAAC0lEQVR42mNkYAAAAAYAAjCB0C8AAAAASUVORK5CYII=" alt="Streaming"/> </div> <div class="layer streaming-image-content"> <img data-target="streamer-name-image-placeholder" class="stream-name-image-placeholder" src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAQAAAC1HAwCAAAAC0lEQVR42mNkYAAAAAYAAjCB0C8AAAAASUVORK5CYII=" alt="Streamer name image"/> </div> </div> <div class="cta-container display-none"> <div class="time-background"> <svg width="20" height="20" viewBox="0 0 20 20" fill="none" xmlns="http://www.w3.org/2000/svg"> <path d="M10 0.5C4.76166 0.5 0.5 4.76166 0.5 10C0.5 15.2383 4.76166 19.5 10 19.5C15.2383 19.5 19.5 15.2383 19.5 10C19.5 4.76166 15.2383 0.5 10 0.5ZM10 18C5.8088 18 2 14.1911 2 10C2 5.80888 5.80888 2 10 2C14.1911 2 18 5.80903 18 10C18 14.191 14.1911 18 10 18Z" fill="var(--cta-action-color)"/> <path d="M10.9495 4.48723H9.05053V10.3948L13.0281 14.3512L14.3674 13.0046L10.9496 9.60541L10.9495 4.48723Z" fill="var(--cta-action-color)"/> </svg> </div> <div> <span class="cta-action" data-i18n="starts"></span> <span class="cta-variable-text"> <strong data-bind="date"></strong> </span> </div> </div> </div> ' }, 2374: (e, t, r) => { "use strict"; r.r(t), r.d(t, { default: () => n }); const n = '<style>.container{display:flex;flex-direction:column}.noselect{-webkit-touch-callout:none;-webkit-user-select:none;-khtml-user-select:none;-moz-user-select:none;-ms-user-select:none;user-select:none}.ratio11{aspect-ratio:1/1;height:100%;width:100%}.wrapper{position:relative;border-radius:100%;overflow:hidden}.layer{position:absolute;top:0;bottom:0;left:0;right:0;border-radius:8px;overflow:hidden;display:flex}.placeholder-streamer img{height:110%;object-fit:cover;margin-left:auto}.stream-event-image-placeholder{height:100%;object-fit:cover;margin-left:auto}.streamer-name{padding-top:8px;font-size:14px;line-height:20px;display:flex;justify-content:center}.layer.placeholder-streamer{justify-content:center}.layer.hide{opacity:0}.base-pattern svg{mix-blend-mode:hard-light;opacity:.8}.gradient-blue .base-backdrop{background:linear-gradient(167.27deg,#60a8ff 0,#4545f0 115.43%)}.gradient-red-purple .base-backdrop{background:linear-gradient(146.31deg,#ff4739 -15%,#a04ef2 115%)}.gradient-aqua .base-backdrop{background:linear-gradient(146.31deg,#61e9ce -15%,#4e4ef2 115%)}.gradient-neon-green .base-backdrop{background:linear-gradient(146.31deg,#1ee46c -15%,#0096c6 115%)}.gradient-purple .base-backdrop{background:linear-gradient(137.59deg,#9c6dff 0,#4545f0 104.95%)}.gradient-pink-blue .base-backdrop{background:linear-gradient(146.31deg,#f143ca -15%,#964ef2 115%)}</style> <div class="container"> <div class="wrapper ratio11 noselect"> <div class="layer base-backdrop"></div> <div class="layer base-pattern"></div> <div class="layer base-tint"></div> <div class="layer"> <img class="ratio11" src="https://assets.livespins.com/room-events/raw/dotted-square.png" alt="Pattern background image"/> </div> <div class="layer placeholder-streamer"> <img data-target="streamer-image-placeholder" src="https://assets.livespins.com/room-events/raw/default-1.png" alt="Streamer placeholder image"/> </div> </div> <span class="streamer-name" data-bind="name"></span> </div> ' }, 5660: (e, t, r) => { "use strict"; r.r(t), r.d(t, { HubConnectionBuilder: () => te }); const n = [0, 2e3, 1e4, 3e4, null]; class s { constructor(e) { this._retryDelays = void 0 !== e ? [...e, null] : n } nextRetryDelayInMilliseconds(e) { return this._retryDelays[e.previousRetryCount] } } class o { } o.Authorization = "Authorization", o.Cookie = "Cookie"; class i { constructor(e, t, r) { this.statusCode = e, this.statusText = t, this.content = r } } class a { get(e, t) { return this.send({ ...t, method: "GET", url: e }) } post(e, t) { return this.send({ ...t, method: "POST", url: e }) } delete(e, t) { return this.send({ ...t, method: "DELETE", url: e }) } getCookieString(e) { return "" } } class c extends a { constructor(e, t) { super(), this._innerClient = e, this._accessTokenFactory = t } async send(e) { let t = !0; this._accessTokenFactory && (!this._accessToken || e.url && e.url.indexOf("/negotiate?") > 0) && (t = !1, this._accessToken = await this._accessTokenFactory()), this._setAuthorizationHeader(e); const r = await this._innerClient.send(e); return t && 401 === r.statusCode && this._accessTokenFactory ? (this._accessToken = await this._accessTokenFactory(), this._setAuthorizationHeader(e), await this._innerClient.send(e)) : r } _setAuthorizationHeader(e) { e.headers || (e.headers = {}), this._accessToken ? e.headers[o.Authorization] = `Bearer ${this._accessToken}` : this._accessTokenFactory && e.headers[o.Authorization] && delete e.headers[o.Authorization] } getCookieString(e) { return this._innerClient.getCookieString(e) } } class l extends Error { constructor(e, t) { const r = new.target.prototype; super(`${e}: Status code '${t}'`), this.statusCode = t, this.__proto__ = r } } class d extends Error { constructor(e = "A timeout occurred.") { const t = new.target.prototype; super(e), this.__proto__ = t } } class u extends Error { constructor(e = "An abort occurred.") { const t = new.target.prototype; super(e), this.__proto__ = t } } class h extends Error { constructor(e, t) { const r = new.target.prototype; super(e), this.transport = t, this.errorType = "UnsupportedTransportError", this.__proto__ = r } } class p extends Error { constructor(e, t) { const r = new.target.prototype; super(e), this.transport = t, this.errorType = "DisabledTransportError", this.__proto__ = r } } class g extends Error { constructor(e, t) { const r = new.target.prototype; super(e), this.transport = t, this.errorType = "FailedToStartTransportError", this.__proto__ = r } } class f extends Error { constructor(e) { const t = new.target.prototype; super(e), this.errorType = "FailedToNegotiateWithServerError", this.__proto__ = t } } class m extends Error { constructor(e, t) { const r = new.target.prototype; super(e), this.innerErrors = t, this.__proto__ = r } } var v; !function (e) { e[e.Trace = 0] = "Trace", e[e.Debug = 1] = "Debug", e[e.Information = 2] = "Information", e[e.Warning = 3] = "Warning", e[e.Error = 4] = "Error", e[e.Critical = 5] = "Critical", e[e.None = 6] = "None" }(v || (v = {})); class b { constructor() { } log(e, t) { } } b.instance = new b; const _ = "8.0.0"; class w { static isRequired(e, t) { if (null == e) throw new Error(`The '${t}' argument is required.`) } static isNotEmpty(e, t) { if (!e || e.match(/^\s*$/)) throw new Error(`The '${t}' argument should not be empty.`) } static isIn(e, t, r) { if (!(e in t)) throw new Error(`Unknown ${r} value: ${e}.`) } } class y { static get isBrowser() { return !y.isNode && "object" == typeof window && "object" == typeof window.document } static get isWebWorker() { return !y.isNode && "object" == typeof self && "importScripts" in self } static get isReactNative() { return !y.isNode && "object" == typeof window && void 0 === window.document } static get isNode() { return "undefined" != typeof process && process.release && "node" === process.release.name } } function S(e, t) { let r = ""; return x(e) ? (r = `Binary data of length ${e.byteLength}`, t && (r += `. Content: '${function (e) { const t = new Uint8Array(e); let r = ""; return t.forEach((e => { r += `0x${e < 16 ? "0" : ""}${e.toString(16)} ` })), r.substr(0, r.length - 1) }(e)}'`)) : "string" == typeof e && (r = `String data of length ${e.length}`, t && (r += `. Content: '${e}'`)), r } function x(e) { return e && "undefined" != typeof ArrayBuffer && (e instanceof ArrayBuffer || e.constructor && "ArrayBuffer" === e.constructor.name) } async function k(e, t, r, n, s, o) { const i = {}, [a, c] = A(); i[a] = c, e.log(v.Trace, `(${t} transport) sending data. ${S(s, o.logMessageContent)}.`); const l = x(s) ? "arraybuffer" : "text", d = await r.post(n, { content: s, headers: { ...i, ...o.headers }, responseType: l, timeout: o.timeout, withCredentials: o.withCredentials }); e.log(v.Trace, `(${t} transport) request complete. Response status: ${d.statusCode}.`) } class C { constructor(e, t) { this._subject = e, this._observer = t } dispose() { const e = this._subject.observers.indexOf(this._observer); e > -1 && this._subject.observers.splice(e, 1), 0 === this._subject.observers.length && this._subject.cancelCallback && this._subject.cancelCallback().catch((e => { })) } } class E { constructor(e) { this._minLevel = e, this.out = console } log(e, t) { if (e >= this._minLevel) { const r = `[${(new Date).toISOString()}] ${v[e]}: ${t}`; switch (e) { case v.Critical: case v.Error: this.out.error(r); break; case v.Warning: this.out.warn(r); break; case v.Information: this.out.info(r); break; default: this.out.log(r) } } } } function A() { let e = "X-SignalR-User-Agent"; return y.isNode && (e = "User-Agent"), [e, T(_, I(), y.isNode ? "NodeJS" : "Browser", P())] } function T(e, t, r, n) { let s = "Microsoft SignalR/"; const o = e.split("."); return s += `${o[0]}.${o[1]}`, s += ` (${e}; `, s += t && "" !== t ? `${t}; ` : "Unknown OS; ", s += `${r}`, s += n ? `; ${n}` : "; Unknown Runtime Version", s += ")", s } function I() { if (!y.isNode) return ""; switch (process.platform) { case "win32": return "Windows NT"; case "darwin": return "macOS"; case "linux": return "Linux"; default: return process.platform } } function P() { if (y.isNode) return process.versions.node } function R(e) { return e.stack ? e.stack : e.message ? e.message : `${e}` } class L extends a { constructor(e) { super(), this._logger = e; const t = { _fetchType: void 0, _jar: void 0 }; var n; n = t, ("undefined" == typeof fetch || y.isNode) && (n._jar = new (r(7333).CookieJar), "undefined" == typeof fetch ? n._fetchType = r(8190) : n._fetchType = fetch, n._fetchType = r(6045)(n._fetchType, n._jar), 1) ? (this._fetchType = t._fetchType, this._jar = t._jar) : this._fetchType = fetch.bind(function () { if ("undefined" != typeof globalThis) return globalThis; if ("undefined" != typeof self) return self; if ("undefined" != typeof window) return window; if (void 0 !== r.g) return r.g; throw new Error("could not find global") }()), this._abortControllerType = AbortController; const s = { _abortControllerType: this._abortControllerType }; (function (e) { return "undefined" == typeof AbortController && (e._abortControllerType = r(6771), !0) })(s) && (this._abortControllerType = s._abortControllerType) } async send(e) { if (e.abortSignal && e.abortSignal.aborted) throw new u; if (!e.method) throw new Error("No method defined."); if (!e.url) throw new Error("No url defined."); const t = new this._abortControllerType; let r; e.abortSignal && (e.abortSignal.onabort = () => { t.abort(), r = new u }); let n, s = null; if (e.timeout) { const n = e.timeout; s = setTimeout((() => { t.abort(), this._logger.log(v.Warning, "Timeout from HTTP request."), r = new d }), n) } "" === e.content && (e.content = void 0), e.content && (e.headers = e.headers || {}, x(e.content) ? e.headers["Content-Type"] = "application/octet-stream" : e.headers["Content-Type"] = "text/plain;charset=UTF-8"); try { n = await this._fetchType(e.url, { body: e.content, cache: "no-cache", credentials: !0 === e.withCredentials ? "include" : "same-origin", headers: { "X-Requested-With": "XMLHttpRequest", ...e.headers }, method: e.method, mode: "cors", redirect: "follow", signal: t.signal }) } catch (e) { if (r) throw r; throw this._logger.log(v.Warning, `Error from HTTP request. ${e}.`), e } finally { s && clearTimeout(s), e.abortSignal && (e.abortSignal.onabort = null) } if (!n.ok) { const e = await M(n, "text"); throw new l(e || n.statusText, n.status) } const o = M(n, e.responseType), a = await o; return new i(n.status, n.statusText, a) } getCookieString(e) { let t = ""; return y.isNode && this._jar && this._jar.getCookies(e, ((e, r) => t = r.join("; "))), t } } function M(e, t) { let r; switch (t) { case "arraybuffer": r = e.arrayBuffer(); break; case "text": default: r = e.text(); break; case "blob": case "document": case "json": throw new Error(`${t} is not supported.`) }return r } class O extends a { constructor(e) { super(), this._logger = e } send(e) { return e.abortSignal && e.abortSignal.aborted ? Promise.reject(new u) : e.method ? e.url ? new Promise(((t, r) => { const n = new XMLHttpRequest; n.open(e.method, e.url, !0), n.withCredentials = void 0 === e.withCredentials || e.withCredentials, n.setRequestHeader("X-Requested-With", "XMLHttpRequest"), "" === e.content && (e.content = void 0), e.content && (x(e.content) ? n.setRequestHeader("Content-Type", "application/octet-stream") : n.setRequestHeader("Content-Type", "text/plain;charset=UTF-8")); const s = e.headers; s && Object.keys(s).forEach((e => { n.setRequestHeader(e, s[e]) })), e.responseType && (n.responseType = e.responseType), e.abortSignal && (e.abortSignal.onabort = () => { n.abort(), r(new u) }), e.timeout && (n.timeout = e.timeout), n.onload = () => { e.abortSignal && (e.abortSignal.onabort = null), n.status >= 200 && n.status < 300 ? t(new i(n.status, n.statusText, n.response || n.responseText)) : r(new l(n.response || n.responseText || n.statusText, n.status)) }, n.onerror = () => { this._logger.log(v.Warning, `Error from HTTP request. ${n.status}: ${n.statusText}.`), r(new l(n.statusText, n.status)) }, n.ontimeout = () => { this._logger.log(v.Warning, "Timeout from HTTP request."), r(new d) }, n.send(e.content) })) : Promise.reject(new Error("No url defined.")) : Promise.reject(new Error("No method defined.")) } } class D extends a { constructor(e) { if (super(), "undefined" != typeof fetch || y.isNode) this._httpClient = new L(e); else { if ("undefined" == typeof XMLHttpRequest) throw new Error("No usable HttpClient found."); this._httpClient = new O(e) } } send(e) { return e.abortSignal && e.abortSignal.aborted ? Promise.reject(new u) : e.method ? e.url ? this._httpClient.send(e) : Promise.reject(new Error("No url defined.")) : Promise.reject(new Error("No method defined.")) } getCookieString(e) { return this._httpClient.getCookieString(e) } } var $, j, N, U; !function (e) { e[e.None = 0] = "None", e[e.WebSockets = 1] = "WebSockets", e[e.ServerSentEvents = 2] = "ServerSentEvents", e[e.LongPolling = 4] = "LongPolling" }($ || ($ = {})), function (e) { e[e.Text = 1] = "Text", e[e.Binary = 2] = "Binary" }(j || (j = {})); class B { constructor() { this._isAborted = !1, this.onabort = null } abort() { this._isAborted || (this._isAborted = !0, this.onabort && this.onabort()) } get signal() { return this } get aborted() { return this._isAborted } } class q { get pollAborted() { return this._pollAbort.aborted } constructor(e, t, r) { this._httpClient = e, this._logger = t, this._pollAbort = new B, this._options = r, this._running = !1, this.onreceive = null, this.onclose = null } async connect(e, t) { if (w.isRequired(e, "url"), w.isRequired(t, "transferFormat"), w.isIn(t, j, "transferFormat"), this._url = e, this._logger.log(v.Trace, "(LongPolling transport) Connecting."), t === j.Binary && "undefined" != typeof XMLHttpRequest && "string" != typeof (new XMLHttpRequest).responseType) throw new Error("Binary protocols over XmlHttpRequest not implementing advanced features are not supported."); const [r, n] = A(), s = { [r]: n, ...this._options.headers }, o = { abortSignal: this._pollAbort.signal, headers: s, timeout: 1e5, withCredentials: this._options.withCredentials }; t === j.Binary && (o.responseType = "arraybuffer"); const i = `${e}&_=${Date.now()}`; this._logger.log(v.Trace, `(LongPolling transport) polling: ${i}.`); const a = await this._httpClient.get(i, o); 200 !== a.statusCode ? (this._logger.log(v.Error, `(LongPolling transport) Unexpected response code: ${a.statusCode}.`), this._closeError = new l(a.statusText || "", a.statusCode), this._running = !1) : this._running = !0, this._receiving = this._poll(this._url, o) } async _poll(e, t) { try { for (; this._running;)try { const r = `${e}&_=${Date.now()}`; this._logger.log(v.Trace, `(LongPolling transport) polling: ${r}.`); const n = await this._httpClient.get(r, t); 204 === n.statusCode ? (this._logger.log(v.Information, "(LongPolling transport) Poll terminated by server."), this._running = !1) : 200 !== n.statusCode ? (this._logger.log(v.Error, `(LongPolling transport) Unexpected response code: ${n.statusCode}.`), this._closeError = new l(n.statusText || "", n.statusCode), this._running = !1) : n.content ? (this._logger.log(v.Trace, `(LongPolling transport) data received. ${S(n.content, this._options.logMessageContent)}.`), this.onreceive && this.onreceive(n.content)) : this._logger.log(v.Trace, "(LongPolling transport) Poll timed out, reissuing.") } catch (e) { this._running ? e instanceof d ? this._logger.log(v.Trace, "(LongPolling transport) Poll timed out, reissuing.") : (this._closeError = e, this._running = !1) : this._logger.log(v.Trace, `(LongPolling transport) Poll errored after shutdown: ${e.message}`) } } finally { this._logger.log(v.Trace, "(LongPolling transport) Polling complete."), this.pollAborted || this._raiseOnClose() } } async send(e) { return this._running ? k(this._logger, "LongPolling", this._httpClient, this._url, e, this._options) : Promise.reject(new Error("Cannot send until the transport is connected")) } async stop() { this._logger.log(v.Trace, "(LongPolling transport) Stopping polling."), this._running = !1, this._pollAbort.abort(); try { await this._receiving, this._logger.log(v.Trace, `(LongPolling transport) sending DELETE request to ${this._url}.`); const e = {}, [t, r] = A(); e[t] = r; const n = { headers: { ...e, ...this._options.headers }, timeout: this._options.timeout, withCredentials: this._options.withCredentials }; let s; try { await this._httpClient.delete(this._url, n) } catch (e) { s = e } s ? s instanceof l && (404 === s.statusCode ? this._logger.log(v.Trace, "(LongPolling transport) A 404 response was returned from sending a DELETE request.") : this._logger.log(v.Trace, `(LongPolling transport) Error sending a DELETE request: ${s}`)) : this._logger.log(v.Trace, "(LongPolling transport) DELETE request accepted.") } finally { this._logger.log(v.Trace, "(LongPolling transport) Stop finished."), this._raiseOnClose() } } _raiseOnClose() { if (this.onclose) { let e = "(LongPolling transport) Firing onclose event."; this._closeError && (e += " Error: " + this._closeError), this._logger.log(v.Trace, e), this.onclose(this._closeError) } } } class H { constructor(e, t, r, n) { this._httpClient = e, this._accessToken = t, this._logger = r, this._options = n, this.onreceive = null, this.onclose = null } async connect(e, t) { return w.isRequired(e, "url"), w.isRequired(t, "transferFormat"), w.isIn(t, j, "transferFormat"), this._logger.log(v.Trace, "(SSE transport) Connecting."), this._url = e, this._accessToken && (e += (e.indexOf("?") < 0 ? "?" : "&") + `access_token=${encodeURIComponent(this._accessToken)}`), new Promise(((r, n) => { let s, o = !1; if (t === j.Text) { if (y.isBrowser || y.isWebWorker) s = new this._options.EventSource(e, { withCredentials: this._options.withCredentials }); else { const t = this._httpClient.getCookieString(e), r = {}; r.Cookie = t; const [n, o] = A(); r[n] = o, s = new this._options.EventSource(e, { withCredentials: this._options.withCredentials, headers: { ...r, ...this._options.headers } }) } try { s.onmessage = e => { if (this.onreceive) try { this._logger.log(v.Trace, `(SSE transport) data received. ${S(e.data, this._options.logMessageContent)}.`), this.onreceive(e.data) } catch (e) { return void this._close(e) } }, s.onerror = e => { o ? this._close() : n(new Error("EventSource failed to connect. The connection could not be found on the server, either the connection ID is not present on the server, or a proxy is refusing/buffering the connection. If you have multiple servers check that sticky sessions are enabled.")) }, s.onopen = () => { this._logger.log(v.Information, `SSE connected to ${this._url}`), this._eventSource = s, o = !0, r() } } catch (e) { return void n(e) } } else n(new Error("The Server-Sent Events transport only supports the 'Text' transfer format")) })) } async send(e) { return this._eventSource ? k(this._logger, "SSE", this._httpClient, this._url, e, this._options) : Promise.reject(new Error("Cannot send until the transport is connected")) } stop() { return this._close(), Promise.resolve() } _close(e) { this._eventSource && (this._eventSource.close(), this._eventSource = void 0, this.onclose && this.onclose(e)) } } class F { constructor(e, t, r, n, s, o) { this._logger = r, this._accessTokenFactory = t, this._logMessageContent = n, this._webSocketConstructor = s, this._httpClient = e, this.onreceive = null, this.onclose = null, this._headers = o } async connect(e, t) { let r; return w.isRequired(e, "url"), w.isRequired(t, "transferFormat"), w.isIn(t, j, "transferFormat"), this._logger.log(v.Trace, "(WebSockets transport) Connecting."), this._accessTokenFactory && (r = await this._accessTokenFactory()), new Promise(((n, s) => { let i; e = e.replace(/^http/, "ws"); const a = this._httpClient.getCookieString(e); let c = !1; if (y.isNode || y.isReactNative) { const t = {}, [n, s] = A(); t[n] = s, r && (t[o.Authorization] = `Bearer ${r}`), a && (t[o.Cookie] = a), i = new this._webSocketConstructor(e, void 0, { headers: { ...t, ...this._headers } }) } else r && (e += (e.indexOf("?") < 0 ? "?" : "&") + `access_token=${encodeURIComponent(r)}`); i || (i = new this._webSocketConstructor(e)), t === j.Binary && (i.binaryType = "arraybuffer"), i.onopen = t => { this._logger.log(v.Information, `WebSocket connected to ${e}.`), this._webSocket = i, c = !0, n() }, i.onerror = e => { let t = null; t = "undefined" != typeof ErrorEvent && e instanceof ErrorEvent ? e.error : "There was an error with the transport", this._logger.log(v.Information, `(WebSockets transport) ${t}.`) }, i.onmessage = e => { if (this._logger.log(v.Trace, `(WebSockets transport) data received. ${S(e.data, this._logMessageContent)}.`), this.onreceive) try { this.onreceive(e.data) } catch (e) { return void this._close(e) } }, i.onclose = e => { if (c) this._close(e); else { let t = null; t = "undefined" != typeof ErrorEvent && e instanceof ErrorEvent ? e.error : "WebSocket failed to connect. The connection could not be found on the server, either the endpoint may not be a SignalR endpoint, the connection ID is not present on the server, or there is a proxy blocking WebSockets. If you have multiple servers check that sticky sessions are enabled.", s(new Error(t)) } } })) } send(e) { return this._webSocket && this._webSocket.readyState === this._webSocketConstructor.OPEN ? (this._logger.log(v.Trace, `(WebSockets transport) sending data. ${S(e, this._logMessageContent)}.`), this._webSocket.send(e), Promise.resolve()) : Promise.reject("WebSocket is not in the OPEN state") } stop() { return this._webSocket && this._close(void 0), Promise.resolve() } _close(e) { this._webSocket && (this._webSocket.onclose = () => { }, this._webSocket.onmessage = () => { }, this._webSocket.onerror = () => { }, this._webSocket.close(), this._webSocket = void 0), this._logger.log(v.Trace, "(WebSockets transport) socket closed."), this.onclose && (!this._isCloseEvent(e) || !1 !== e.wasClean && 1e3 === e.code ? e instanceof Error ? this.onclose(e) : this.onclose() : this.onclose(new Error(`WebSocket closed with status code: ${e.code} (${e.reason || "no reason given"}).`))) } _isCloseEvent(e) { return e && "boolean" == typeof e.wasClean && "number" == typeof e.code } } class W { constructor(e, t = {}) { var n; if (this._stopPromiseResolver = () => { }, this.features = {}, this._negotiateVersion = 1, w.isRequired(e, "url"), this._logger = void 0 === (n = t.logger) ? new E(v.Information) : null === n ? b.instance : void 0 !== n.log ? n : new E(n), this.baseUrl = this._resolveUrl(e), (t = t || {}).logMessageContent = void 0 !== t.logMessageContent && t.logMessageContent, "boolean" != typeof t.withCredentials && void 0 !== t.withCredentials) throw new Error("withCredentials option was not a 'boolean' or 'undefined' value"); t.withCredentials = void 0 === t.withCredentials || t.withCredentials, t.timeout = void 0 === t.timeout ? 1e5 : t.timeout; let s = null, o = null; y.isNode && (s = r(6139), o = r(8022)), y.isNode || "undefined" == typeof WebSocket || t.WebSocket ? y.isNode && !t.WebSocket && s && (t.WebSocket = s) : t.WebSocket = WebSocket, y.isNode || "undefined" == typeof EventSource || t.EventSource ? y.isNode && !t.EventSource && void 0 !== o && (t.EventSource = o) : t.EventSource = EventSource, this._httpClient = new c(t.httpClient || new D(this._logger), t.accessTokenFactory), this._connectionState = "Disconnected", this._connectionStarted = !1, this._options = t, this.onreceive = null, this.onclose = null } async start(e) { if (e = e || j.Binary, w.isIn(e, j, "transferFormat"), this._logger.log(v.Debug, `Starting connection with transfer format '${j[e]}'.`), "Disconnected" !== this._connectionState) return Promise.reject(new Error("Cannot start an HttpConnection that is not in the 'Disconnected' state.")); if (this._connectionState = "Connecting", this._startInternalPromise = this._startInternal(e), await this._startInternalPromise, "Disconnecting" === this._connectionState) { const e = "Failed to start the HttpConnection before stop() was called."; return this._logger.log(v.Error, e), await this._stopPromise, Promise.reject(new u(e)) } if ("Connected" !== this._connectionState) { const e = "HttpConnection.startInternal completed gracefully but didn't enter the connection into the connected state!"; return this._logger.log(v.Error, e), Promise.reject(new u(e)) } this._connectionStarted = !0 } send(e) { return "Connected" !== this._connectionState ? Promise.reject(new Error("Cannot send data if the connection is not in the 'Connected' State.")) : (this._sendQueue || (this._sendQueue = new z(this.transport)), this._sendQueue.send(e)) } async stop(e) { return "Disconnected" === this._connectionState ? (this._logger.log(v.Debug, `Call to HttpConnection.stop(${e}) ignored because the connection is already in the disconnected state.`), Promise.resolve()) : "Disconnecting" === this._connectionState ? (this._logger.log(v.Debug, `Call to HttpConnection.stop(${e}) ignored because the connection is already in the disconnecting state.`), this._stopPromise) : (this._connectionState = "Disconnecting", this._stopPromise = new Promise((e => { this._stopPromiseResolver = e })), await this._stopInternal(e), void await this._stopPromise) } async _stopInternal(e) { this._stopError = e; try { await this._startInternalPromise } catch (e) { } if (this.transport) { try { await this.transport.stop() } catch (e) { this._logger.log(v.Error, `HttpConnection.transport.stop() threw error '${e}'.`), this._stopConnection() } this.transport = void 0 } else this._logger.log(v.Debug, "HttpConnection.transport is undefined in HttpConnection.stop() because start() failed.") } async _startInternal(e) { let t = this.baseUrl; this._accessTokenFactory = this._options.accessTokenFactory, this._httpClient._accessTokenFactory = this._accessTokenFactory; try { if (this._options.skipNegotiation) { if (this._options.transport !== $.WebSockets) throw new Error("Negotiation can only be skipped when using the WebSocket transport directly."); this.transport = this._constructTransport($.WebSockets), await this._startTransport(t, e) } else { let r = null, n = 0; do { if (r = await this._getNegotiationResponse(t), "Disconnecting" === this._connectionState || "Disconnected" === this._connectionState) throw new u("The connection was stopped during negotiation."); if (r.error) throw new Error(r.error); if (r.ProtocolVersion) throw new Error("Detected a connection attempt to an ASP.NET SignalR Server. This client only supports connecting to an ASP.NET Core SignalR Server. See https://aka.ms/signalr-core-differences for details."); if (r.url && (t = r.url), r.accessToken) { const e = r.accessToken; this._accessTokenFactory = () => e, this._httpClient._accessToken = e, this._httpClient._accessTokenFactory = void 0 } n++ } while (r.url && n < 100); if (100 === n && r.url) throw new Error("Negotiate redirection limit exceeded."); await this._createTransport(t, this._options.transport, r, e) } this.transport instanceof q && (this.features.inherentKeepAlive = !0), "Connecting" === this._connectionState && (this._logger.log(v.Debug, "The HttpConnection connected successfully."), this._connectionState = "Connected") } catch (e) { return this._logger.log(v.Error, "Failed to start the connection: " + e), this._connectionState = "Disconnected", this.transport = void 0, this._stopPromiseResolver(), Promise.reject(e) } } async _getNegotiationResponse(e) { const t = {}, [r, n] = A(); t[r] = n; const s = this._resolveNegotiateUrl(e); this._logger.log(v.Debug, `Sending negotiation request: ${s}.`); try { const e = await this._httpClient.post(s, { content: "", headers: { ...t, ...this._options.headers }, timeout: this._options.timeout, withCredentials: this._options.withCredentials }); if (200 !== e.statusCode) return Promise.reject(new Error(`Unexpected status code returned from negotiate '${e.statusCode}'`)); const r = JSON.parse(e.content); return (!r.negotiateVersion || r.negotiateVersion < 1) && (r.connectionToken = r.connectionId), r.useStatefulReconnect && !0 !== this._options._useStatefulReconnect ? Promise.reject(new f("Client didn't negotiate Stateful Reconnect but the server did.")) : r } catch (e) { let t = "Failed to complete negotiation with the server: " + e; return e instanceof l && 404 === e.statusCode && (t += " Either this is not a SignalR endpoint or there is a proxy blocking the connection."), this._logger.log(v.Error, t), Promise.reject(new f(t)) } } _createConnectUrl(e, t) { return t ? e + (-1 === e.indexOf("?") ? "?" : "&") + `id=${t}` : e } async _createTransport(e, t, r, n) { let s = this._createConnectUrl(e, r.connectionToken); if (this._isITransport(t)) return this._logger.log(v.Debug, "Connection was provided an instance of ITransport, using that directly."), this.transport = t, await this._startTransport(s, n), void (this.connectionId = r.connectionId); const o = [], i = r.availableTransports || []; let a = r; for (const r of i) { const i = this._resolveTransportOrError(r, t, n, !0 === (null == a ? void 0 : a.useStatefulReconnect)); if (i instanceof Error) o.push(`${r.transport} failed:`), o.push(i); else if (this._isITransport(i)) { if (this.transport = i, !a) { try { a = await this._getNegotiationResponse(e) } catch (e) { return Promise.reject(e) } s = this._createConnectUrl(e, a.connectionToken) } try { return await this._startTransport(s, n), void (this.connectionId = a.connectionId) } catch (e) { if (this._logger.log(v.Error, `Failed to start the transport '${r.transport}': ${e}`), a = void 0, o.push(new g(`${r.transport} failed: ${e}`, $[r.transport])), "Connecting" !== this._connectionState) { const e = "Failed to select transport before stop() was called."; return this._logger.log(v.Debug, e), Promise.reject(new u(e)) } } } } return o.length > 0 ? Promise.reject(new m(`Unable to connect to the server with any of the available transports. ${o.join(" ")}`, o)) : Promise.reject(new Error("None of the transports supported by the client are supported by the server.")) } _constructTransport(e) { switch (e) { case $.WebSockets: if (!this._options.WebSocket) throw new Error("'WebSocket' is not supported in your environment."); return new F(this._httpClient, this._accessTokenFactory, this._logger, this._options.logMessageContent, this._options.WebSocket, this._options.headers || {}); case $.ServerSentEvents: if (!this._options.EventSource) throw new Error("'EventSource' is not supported in your environment."); return new H(this._httpClient, this._httpClient._accessToken, this._logger, this._options); case $.LongPolling: return new q(this._httpClient, this._logger, this._options); default: throw new Error(`Unknown transport: ${e}.`) } } _startTransport(e, t) { return this.transport.onreceive = this.onreceive, this.features.reconnect ? this.transport.onclose = async r => { let n = !1; if (this.features.reconnect) { try { this.features.disconnected(), await this.transport.connect(e, t), await this.features.resend() } catch { n = !0 } n && this._stopConnection(r) } else this._stopConnection(r) } : this.transport.onclose = e => this._stopConnection(e), this.transport.connect(e, t) } _resolveTransportOrError(e, t, r, n) { const s = $[e.transport]; if (null == s) return this._logger.log(v.Debug, `Skipping transport '${e.transport}' because it is not supported by this client.`), new Error(`Skipping transport '${e.transport}' because it is not supported by this client.`); if (!function (e, t) { return !e || 0 != (t & e) }(t, s)) return this._logger.log(v.Debug, `Skipping transport '${$[s]}' because it was disabled by the client.`), new p(`'${$[s]}' is disabled by the client.`, s); if (!(e.transferFormats.map((e => j[e])).indexOf(r) >= 0)) return this._logger.log(v.Debug, `Skipping transport '${$[s]}' because it does not support the requested transfer format '${j[r]}'.`), new Error(`'${$[s]}' does not support ${j[r]}.`); if (s === $.WebSockets && !this._options.WebSocket || s === $.ServerSentEvents && !this._options.EventSource) return this._logger.log(v.Debug, `Skipping transport '${$[s]}' because it is not supported in your environment.'`), new h(`'${$[s]}' is not supported in your environment.`, s); this._logger.log(v.Debug, `Selecting transport '${$[s]}'.`); try { return this.features.reconnect = s === $.WebSockets ? n : void 0, this._constructTransport(s) } catch (e) { return e } } _isITransport(e) { return e && "object" == typeof e && "connect" in e } _stopConnection(e) { if (this._logger.log(v.Debug, `HttpConnection.stopConnection(${e}) called while in state ${this._connectionState}.`), this.transport = void 0, e = this._stopError || e, this._stopError = void 0, "Disconnected" !== this._connectionState) { if ("Connecting" === this._connectionState) throw this._logger.log(v.Warning, `Call to HttpConnection.stopConnection(${e}) was ignored because the connection is still in the connecting state.`), new Error(`HttpConnection.stopConnection(${e}) was called while the connection is still in the connecting state.`); if ("Disconnecting" === this._connectionState && this._stopPromiseResolver(), e ? this._logger.log(v.Error, `Connection disconnected with error '${e}'.`) : this._logger.log(v.Information, "Connection disconnected."), this._sendQueue && (this._sendQueue.stop().catch((e => { this._logger.log(v.Error, `TransportSendQueue.stop() threw error '${e}'.`) })), this._sendQueue = void 0), this.connectionId = void 0, this._connectionState = "Disconnected", this._connectionStarted) { this._connectionStarted = !1; try { this.onclose && this.onclose(e) } catch (t) { this._logger.log(v.Error, `HttpConnection.onclose(${e}) threw error '${t}'.`) } } } else this._logger.log(v.Debug, `Call to HttpConnection.stopConnection(${e}) was ignored because the connection is already in the disconnected state.`) } _resolveUrl(e) { if (0 === e.lastIndexOf("https://", 0) || 0 === e.lastIndexOf("http://", 0)) return e; if (!y.isBrowser) throw new Error(`Cannot resolve '${e}'.`); const t = window.document.createElement("a"); return t.href = e, this._logger.log(v.Information, `Normalizing '${e}' to '${t.href}'.`), t.href } _resolveNegotiateUrl(e) { const t = new URL(e); t.pathname.endsWith("/") ? t.pathname += "negotiate" : t.pathname += "/negotiate"; const r = new URLSearchParams(t.searchParams); return r.has("negotiateVersion") || r.append("negotiateVersion", this._negotiateVersion.toString()), r.has("useStatefulReconnect") ? "true" === r.get("useStatefulReconnect") && (this._options._useStatefulReconnect = !0) : !0 === this._options._useStatefulReconnect && r.append("useStatefulReconnect", "true"), t.search = r.toString(), t.toString() } } class z { constructor(e) { this._transport = e, this._buffer = [], this._executing = !0, this._sendBufferedData = new J, this._transportResult = new J, this._sendLoopPromise = this._sendLoop() } send(e) { return this._bufferData(e), this._transportResult || (this._transportResult = new J), this._transportResult.promise } stop() { return this._executing = !1, this._sendBufferedData.resolve(), this._sendLoopPromise } _bufferData(e) { if (this._buffer.length && typeof this._buffer[0] != typeof e) throw new Error(`Expected data to be of type ${typeof this._buffer} but was of type ${typeof e}`); this._buffer.push(e), this._sendBufferedData.resolve() } async _sendLoop() { for (; ;) { if (await this._sendBufferedData.promise, !this._executing) { this._transportResult && this._transportResult.reject("Connection stopped."); break } this._sendBufferedData = new J; const e = this._transportResult; this._transportResult = void 0; const t = "string" == typeof this._buffer[0] ? this._buffer.join("") : z._concatBuffers(this._buffer); this._buffer.length = 0; try { await this._transport.send(t), e.resolve() } catch (t) { e.reject(t) } } } static _concatBuffers(e) { const t = e.map((e => e.byteLength)).reduce(((e, t) => e + t)), r = new Uint8Array(t); let n = 0; for (const t of e) r.set(new Uint8Array(t), n), n += t.byteLength; return r.buffer } } class J { constructor() { this.promise = new Promise(((e, t) => [this._resolver, this._rejecter] = [e, t])) } resolve() { this._resolver() } reject(e) { this._rejecter(e) } } class V { static write(e) { return `${e}${V.RecordSeparator}` } static parse(e) { if (e[e.length - 1] !== V.RecordSeparator) throw new Error("Message is incomplete."); const t = e.split(V.RecordSeparator); return t.pop(), t } } V.RecordSeparatorCode = 30, V.RecordSeparator = String.fromCharCode(V.RecordSeparatorCode); class Y { writeHandshakeRequest(e) { return V.write(JSON.stringify(e)) } parseHandshakeResponse(e) { let t, r; if (x(e)) { const n = new Uint8Array(e), s = n.indexOf(V.RecordSeparatorCode); if (-1 === s) throw new Error("Message is incomplete."); const o = s + 1; t = String.fromCharCode.apply(null, Array.prototype.slice.call(n.slice(0, o))), r = n.byteLength > o ? n.slice(o).buffer : null } else { const n = e, s = n.indexOf(V.RecordSeparator); if (-1 === s) throw new Error("Message is incomplete."); const o = s + 1; t = n.substring(0, o), r = n.length > o ? n.substring(o) : null } const n = V.parse(t), s = JSON.parse(n[0]); if (s.type) throw new Error("Expected a handshake response from the server."); return [r, s] } } !function (e) { e[e.Invocation = 1] = "Invocation", e[e.StreamItem = 2] = "StreamItem", e[e.Completion = 3] = "Completion", e[e.StreamInvocation = 4] = "StreamInvocation", e[e.CancelInvocation = 5] = "CancelInvocation", e[e.Ping = 6] = "Ping", e[e.Close = 7] = "Close", e[e.Ack = 8] = "Ack", e[e.Sequence = 9] = "Sequence" }(N || (N = {})); class K { constructor() { this.observers = [] } next(e) { for (const t of this.observers) t.next(e) } error(e) { for (const t of this.observers) t.error && t.error(e) } complete() { for (const e of this.observers) e.complete && e.complete() } subscribe(e) { return this.observers.push(e), new C(this, e) } } class G { constructor(e, t, r) { this._bufferSize = 1e5, this._messages = [], this._totalMessageCount = 0, this._waitForSequenceMessage = !1, this._nextReceivingSequenceId = 1, this._latestReceivedSequenceId = 0, this._bufferedByteCount = 0, this._reconnectInProgress = !1, this._protocol = e, this._connection = t, this._bufferSize = r } async _send(e) { const t = this._protocol.writeMessage(e); let r = Promise.resolve(); if (this._isInvocationMessage(e)) { this._totalMessageCount++; let e = () => { }, n = () => { }; x(t) ? this._bufferedByteCount += t.byteLength : this._bufferedByteCount += t.length, this._bufferedByteCount >= this._bufferSize && (r = new Promise(((t, r) => { e = t, n = r }))), this._messages.push(new Q(t, this._totalMessageCount, e, n)) } try { this._reconnectInProgress || await this._connection.send(t) } catch { this._disconnected() } await r } _ack(e) { let t = -1; for (let r = 0; r < this._messages.length; r++) { const n = this._messages[r]; if (n._id <= e.sequenceId) t = r, x(n._message) ? this._bufferedByteCount -= n._message.byteLength : this._bufferedByteCount -= n._message.length, n._resolver(); else { if (!(this._bufferedByteCount < this._bufferSize)) break; n._resolver() } } -1 !== t && (this._messages = this._messages.slice(t + 1)) } _shouldProcessMessage(e) { if (this._waitForSequenceMessage) return e.type === N.Sequence && (this._waitForSequenceMessage = !1, !0); if (!this._isInvocationMessage(e)) return !0; const t = this._nextReceivingSequenceId; return this._nextReceivingSequenceId++, t <= this._latestReceivedSequenceId ? (t === this._latestReceivedSequenceId && this._ackTimer(), !1) : (this._latestReceivedSequenceId = t, this._ackTimer(), !0) } _resetSequence(e) { e.sequenceId > this._nextReceivingSequenceId ? this._connection.stop(new Error("Sequence ID greater than amount of messages we've received.")) : this._nextReceivingSequenceId = e.sequenceId } _disconnected() { this._reconnectInProgress = !0, this._waitForSequenceMessage = !0 } async _resend() { const e = 0 !== this._messages.length ? this._messages[0]._id : this._totalMessageCount + 1; await this._connection.send(this._protocol.writeMessage({ type: N.Sequence, sequenceId: e })); const t = this._messages; for (const e of t) await this._connection.send(e._message); this._reconnectInProgress = !1 } _dispose(e) { null != e || (e = new Error("Unable to reconnect to server.")); for (const t of this._messages) t._rejector(e) } _isInvocationMessage(e) { switch (e.type) { case N.Invocation: case N.StreamItem: case N.Completion: case N.StreamInvocation: case N.CancelInvocation: return !0; case N.Close: case N.Sequence: case N.Ping: case N.Ack: return !1 } } _ackTimer() { void 0 === this._ackTimerHandle && (this._ackTimerHandle = setTimeout((async () => { try { this._reconnectInProgress || await this._connection.send(this._protocol.writeMessage({ type: N.Ack, sequenceId: this._latestReceivedSequenceId })) } catch { } clearTimeout(this._ackTimerHandle), this._ackTimerHandle = void 0 }), 1e3)) } } class Q { constructor(e, t, r, n) { this._message = e, this._id = t, this._resolver = r, this._rejector = n } } !function (e) { e.Disconnected = "Disconnected", e.Connecting = "Connecting", e.Connected = "Connected", e.Disconnecting = "Disconnecting", e.Reconnecting = "Reconnecting" }(U || (U = {})); class Z { static create(e, t, r, n, s, o, i) { return new Z(e, t, r, n, s, o, i) } constructor(e, t, r, n, s, o, i) { this._nextKeepAlive = 0, this._freezeEventListener = () => { this._logger.log(v.Warning, "The page is being frozen, this will likely lead to the connection being closed and messages being lost. For more information see the docs at https://learn.microsoft.com/aspnet/core/signalr/javascript-client#bsleep") }, w.isRequired(e, "connection"), w.isRequired(t, "logger"), w.isRequired(r, "protocol"), this.serverTimeoutInMilliseconds = null != s ? s : 3e4, this.keepAliveIntervalInMilliseconds = null != o ? o : 15e3, this._statefulReconnectBufferSize = null != i ? i : 1e5, this._logger = t, this._protocol = r, this.connection = e, this._reconnectPolicy = n, this._handshakeProtocol = new Y, this.connection.onreceive = e => this._processIncomingData(e), this.connection.onclose = e => this._connectionClosed(e), this._callbacks = {}, this._methods = {}, this._closedCallbacks = [], this._reconnectingCallbacks = [], this._reconnectedCallbacks = [], this._invocationId = 0, this._receivedHandshakeResponse = !1, this._connectionState = U.Disconnected, this._connectionStarted = !1, this._cachedPingMessage = this._protocol.writeMessage({ type: N.Ping }) } get state() { return this._connectionState } get connectionId() { return this.connection && this.connection.connectionId || null } get baseUrl() { return this.connection.baseUrl || "" } set baseUrl(e) { if (this._connectionState !== U.Disconnected && this._connectionState !== U.Reconnecting) throw new Error("The HubConnection must be in the Disconnected or Reconnecting state to change the url."); if (!e) throw new Error("The HubConnection url must be a valid url."); this.connection.baseUrl = e } start() { return this._startPromise = this._startWithStateTransitions(), this._startPromise } async _startWithStateTransitions() { if (this._connectionState !== U.Disconnected) return Promise.reject(new Error("Cannot start a HubConnection that is not in the 'Disconnected' state.")); this._connectionState = U.Connecting, this._logger.log(v.Debug, "Starting HubConnection."); try { await this._startInternal(), y.isBrowser && window.document.addEventListener("freeze", this._freezeEventListener), this._connectionState = U.Connected, this._connectionStarted = !0, this._logger.log(v.Debug, "HubConnection connected successfully.") } catch (e) { return this._connectionState = U.Disconnected, this._logger.log(v.Debug, `HubConnection failed to start successfully because of error '${e}'.`), Promise.reject(e) } } async _startInternal() { this._stopDuringStartError = void 0, this._receivedHandshakeResponse = !1; const e = new Promise(((e, t) => { this._handshakeResolver = e, this._handshakeRejecter = t })); await this.connection.start(this._protocol.transferFormat); try { let t = this._protocol.version; this.connection.features.reconnect || (t = 1); const r = { protocol: this._protocol.name, version: t }; if (this._logger.log(v.Debug, "Sending handshake request."), await this._sendMessage(this._handshakeProtocol.writeHandshakeRequest(r)), this._logger.log(v.Information, `Using HubProtocol '${this._protocol.name}'.`), this._cleanupTimeout(), this._resetTimeoutPeriod(), this._resetKeepAliveInterval(), await e, this._stopDuringStartError) throw this._stopDuringStartError; !!this.connection.features.reconnect && (this._messageBuffer = new G(this._protocol, this.connection, this._statefulReconnectBufferSize), this.connection.features.disconnected = this._messageBuffer._disconnected.bind(this._messageBuffer), this.connection.features.resend = () => { if (this._messageBuffer) return this._messageBuffer._resend() }), this.connection.features.inherentKeepAlive || await this._sendMessage(this._cachedPingMessage) } catch (e) { throw this._logger.log(v.Debug, `Hub handshake failed with error '${e}' during start(). Stopping HubConnection.`), this._cleanupTimeout(), this._cleanupPingTimer(), await this.connection.stop(e), e } } async stop() { const e = this._startPromise; this.connection.features.reconnect = !1, this._stopPromise = this._stopInternal(), await this._stopPromise; try { await e } catch (e) { } } _stopInternal(e) { if (this._connectionState === U.Disconnected) return this._logger.log(v.Debug, `Call to HubConnection.stop(${e}) ignored because it is already in the disconnected state.`), Promise.resolve(); if (this._connectionState === U.Disconnecting) return this._logger.log(v.Debug, `Call to HttpConnection.stop(${e}) ignored because the connection is already in the disconnecting state.`), this._stopPromise; const t = this._connectionState; return this._connectionState = U.Disconnecting, this._logger.log(v.Debug, "Stopping HubConnection."), this._reconnectDelayHandle ? (this._logger.log(v.Debug, "Connection stopped during reconnect delay. Done reconnecting."), clearTimeout(this._reconnectDelayHandle), this._reconnectDelayHandle = void 0, this._completeClose(), Promise.resolve()) : (t === U.Connected && this._sendCloseMessage(), this._cleanupTimeout(), this._cleanupPingTimer(), this._stopDuringStartError = e || new u("The connection was stopped before the hub handshake could complete."), this.connection.stop(e)) } async _sendCloseMessage() { try { await this._sendWithProtocol(this._createCloseMessage()) } catch { } } stream(e, ...t) { const [r, n] = this._replaceStreamingParams(t), s = this._createStreamInvocation(e, t, n); let o; const i = new K; return i.cancelCallback = () => { const e = this._createCancelInvocation(s.invocationId); return delete this._callbacks[s.invocationId], o.then((() => this._sendWithProtocol(e))) }, this._callbacks[s.invocationId] = (e, t) => { t ? i.error(t) : e && (e.type === N.Completion ? e.error ? i.error(new Error(e.error)) : i.complete() : i.next(e.item)) }, o = this._sendWithProtocol(s).catch((e => { i.error(e), delete this._callbacks[s.invocationId] })), this._launchStreams(r, o), i } _sendMessage(e) { return this._resetKeepAliveInterval(), this.connection.send(e) } _sendWithProtocol(e) { return this._messageBuffer ? this._messageBuffer._send(e) : this._sendMessage(this._protocol.writeMessage(e)) } send(e, ...t) { const [r, n] = this._replaceStreamingParams(t), s = this._sendWithProtocol(this._createInvocation(e, t, !0, n)); return this._launchStreams(r, s), s } invoke(e, ...t) { const [r, n] = this._replaceStreamingParams(t), s = this._createInvocation(e, t, !1, n); return new Promise(((e, t) => { this._callbacks[s.invocationId] = (r, n) => { n ? t(n) : r && (r.type === N.Completion ? r.error ? t(new Error(r.error)) : e(r.result) : t(new Error(`Unexpected message type: ${r.type}`))) }; const n = this._sendWithProtocol(s).catch((e => { t(e), delete this._callbacks[s.invocationId] })); this._launchStreams(r, n) })) } on(e, t) { e && t && (e = e.toLowerCase(), this._methods[e] || (this._methods[e] = []), -1 === this._methods[e].indexOf(t) && this._methods[e].push(t)) } off(e, t) { if (!e) return; e = e.toLowerCase(); const r = this._methods[e]; if (r) if (t) { const n = r.indexOf(t); -1 !== n && (r.splice(n, 1), 0 === r.length && delete this._methods[e]) } else delete this._methods[e] } onclose(e) { e && this._closedCallbacks.push(e) } onreconnecting(e) { e && this._reconnectingCallbacks.push(e) } onreconnected(e) { e && this._reconnectedCallbacks.push(e) } _processIncomingData(e) { if (this._cleanupTimeout(), this._receivedHandshakeResponse || (e = this._processHandshakeResponse(e), this._receivedHandshakeResponse = !0), e) { const t = this._protocol.parseMessages(e, this._logger); for (const e of t) if (!this._messageBuffer || this._messageBuffer._shouldProcessMessage(e)) switch (e.type) { case N.Invocation: this._invokeClientMethod(e); break; case N.StreamItem: case N.Completion: { const t = this._callbacks[e.invocationId]; if (t) { e.type === N.Completion && delete this._callbacks[e.invocationId]; try { t(e) } catch (e) { this._logger.log(v.Error, `Stream callback threw error: ${R(e)}`) } } break } case N.Ping: break; case N.Close: { this._logger.log(v.Information, "Close message received from server."); const t = e.error ? new Error("Server returned an error on close: " + e.error) : void 0; !0 === e.allowReconnect ? this.connection.stop(t) : this._stopPromise = this._stopInternal(t); break } case N.Ack: this._messageBuffer && this._messageBuffer._ack(e); break; case N.Sequence: this._messageBuffer && this._messageBuffer._resetSequence(e); break; default: this._logger.log(v.Warning, `Invalid message type: ${e.type}.`) } } this._resetTimeoutPeriod() } _processHandshakeResponse(e) { let t, r; try { [r, t] = this._handshakeProtocol.parseHandshakeResponse(e) } catch (e) { const t = "Error parsing handshake response: " + e; this._logger.log(v.Error, t); const r = new Error(t); throw this._handshakeRejecter(r), r } if (t.error) { const e = "Server returned handshake error: " + t.error; this._logger.log(v.Error, e); const r = new Error(e); throw this._handshakeRejecter(r), r } return this._logger.log(v.Debug, "Server handshake complete."), this._handshakeResolver(), r } _resetKeepAliveInterval() { this.connection.features.inherentKeepAlive || (this._nextKeepAlive = (new Date).getTime() + this.keepAliveIntervalInMilliseconds, this._cleanupPingTimer()) } _resetTimeoutPeriod() { if (!(this.connection.features && this.connection.features.inherentKeepAlive || (this._timeoutHandle = setTimeout((() => this.serverTimeout()), this.serverTimeoutInMilliseconds), void 0 !== this._pingServerHandle))) { let e = this._nextKeepAlive - (new Date).getTime(); e < 0 && (e = 0), this._pingServerHandle = setTimeout((async () => { if (this._connectionState === U.Connected) try { await this._sendMessage(this._cachedPingMessage) } catch { this._cleanupPingTimer() } }), e) } } serverTimeout() { this.connection.stop(new Error("Server timeout elapsed without receiving a message from the server.")) } async _invokeClientMethod(e) { const t = e.target.toLowerCase(), r = this._methods[t]; if (!r) return this._logger.log(v.Warning, `No client method with the name '${t}' found.`), void (e.invocationId && (this._logger.log(v.Warning, `No result given for '${t}' method and invocation ID '${e.invocationId}'.`), await this._sendWithProtocol(this._createCompletionMessage(e.invocationId, "Client didn't provide a result.", null)))); const n = r.slice(), s = !!e.invocationId; let o, i, a; for (const r of n) try { const n = o; o = await r.apply(this, e.arguments), s && o && n && (this._logger.log(v.Error, `Multiple results provided for '${t}'. Sending error to server.`), a = this._createCompletionMessage(e.invocationId, "Client provided multiple results.", null)), i = void 0 } catch (e) { i = e, this._logger.log(v.Error, `A callback for the method '${t}' threw error '${e}'.`) } a ? await this._sendWithProtocol(a) : s ? (i ? a = this._createCompletionMessage(e.invocationId, `${i}`, null) : void 0 !== o ? a = this._createCompletionMessage(e.invocationId, null, o) : (this._logger.log(v.Warning, `No result given for '${t}' method and invocation ID '${e.invocationId}'.`), a = this._createCompletionMessage(e.invocationId, "Client didn't provide a result.", null)), await this._sendWithProtocol(a)) : o && this._logger.log(v.Error, `Result given for '${t}' method but server is not expecting a result.`) } _connectionClosed(e) { this._logger.log(v.Debug, `HubConnection.connectionClosed(${e}) called while in state ${this._connectionState}.`), this._stopDuringStartError = this._stopDuringStartError || e || new u("The underlying connection was closed before the hub handshake could complete."), this._handshakeResolver && this._handshakeResolver(), this._cancelCallbacksWithError(e || new Error("Invocation canceled due to the underlying connection being closed.")), this._cleanupTimeout(), this._cleanupPingTimer(), this._connectionState === U.Disconnecting ? this._completeClose(e) : this._connectionState === U.Connected && this._reconnectPolicy ? this._reconnect(e) : this._connectionState === U.Connected && this._completeClose(e) } _completeClose(e) { if (this._connectionStarted) { this._connectionState = U.Disconnected, this._connectionStarted = !1, this._messageBuffer && (this._messageBuffer._dispose(null != e ? e : new Error("Connection closed.")), this._messageBuffer = void 0), y.isBrowser && window.document.removeEventListener("freeze", this._freezeEventListener); try { this._closedCallbacks.forEach((t => t.apply(this, [e]))) } catch (t) { this._logger.log(v.Error, `An onclose callback called with error '${e}' threw error '${t}'.`) } } } async _reconnect(e) { const t = Date.now(); let r = 0, n = void 0 !== e ? e : new Error("Attempting to reconnect due to a unknown error."), s = this._getNextRetryDelay(r++, 0, n); if (null === s) return this._logger.log(v.Debug, "Connection not reconnecting because the IRetryPolicy returned null on the first reconnect attempt."), void this._completeClose(e); if (this._connectionState = U.Reconnecting, e ? this._logger.log(v.Information, `Connection reconnecting because of error '${e}'.`) : this._logger.log(v.Information, "Connection reconnecting."), 0 !== this._reconnectingCallbacks.length) { try { this._reconnectingCallbacks.forEach((t => t.apply(this, [e]))) } catch (t) { this._logger.log(v.Error, `An onreconnecting callback called with error '${e}' threw error '${t}'.`) } if (this._connectionState !== U.Reconnecting) return void this._logger.log(v.Debug, "Connection left the reconnecting state in onreconnecting callback. Done reconnecting.") } for (; null !== s;) { if (this._logger.log(v.Information, `Reconnect attempt number ${r} will start in ${s} ms.`), await new Promise((e => { this._reconnectDelayHandle = setTimeout(e, s) })), this._reconnectDelayHandle = void 0, this._connectionState !== U.Reconnecting) return void this._logger.log(v.Debug, "Connection left the reconnecting state during reconnect delay. Done reconnecting."); try { if (await this._startInternal(), this._connectionState = U.Connected, this._logger.log(v.Information, "HubConnection reconnected successfully."), 0 !== this._reconnectedCallbacks.length) try { this._reconnectedCallbacks.forEach((e => e.apply(this, [this.connection.connectionId]))) } catch (e) { this._logger.log(v.Error, `An onreconnected callback called with connectionId '${this.connection.connectionId}; threw error '${e}'.`) } return } catch (e) { if (this._logger.log(v.Information, `Reconnect attempt failed because of error '${e}'.`), this._connectionState !== U.Reconnecting) return this._logger.log(v.Debug, `Connection moved to the '${this._connectionState}' from the reconnecting state during reconnect attempt. Done reconnecting.`), void (this._connectionState === U.Disconnecting && this._completeClose()); n = e instanceof Error ? e : new Error(e.toString()), s = this._getNextRetryDelay(r++, Date.now() - t, n) } } this._logger.log(v.Information, `Reconnect retries have been exhausted after ${Date.now() - t} ms and ${r} failed attempts. Connection disconnecting.`), this._completeClose() } _getNextRetryDelay(e, t, r) { try { return this._reconnectPolicy.nextRetryDelayInMilliseconds({ elapsedMilliseconds: t, previousRetryCount: e, retryReason: r }) } catch (r) { return this._logger.log(v.Error, `IRetryPolicy.nextRetryDelayInMilliseconds(${e}, ${t}) threw error '${r}'.`), null } } _cancelCallbacksWithError(e) { const t = this._callbacks; this._callbacks = {}, Object.keys(t).forEach((r => { const n = t[r]; try { n(null, e) } catch (t) { this._logger.log(v.Error, `Stream 'error' callback called with '${e}' threw error: ${R(t)}`) } })) } _cleanupPingTimer() { this._pingServerHandle && (clearTimeout(this._pingServerHandle), this._pingServerHandle = void 0) } _cleanupTimeout() { this._timeoutHandle && clearTimeout(this._timeoutHandle) } _createInvocation(e, t, r, n) { if (r) return 0 !== n.length ? { arguments: t, streamIds: n, target: e, type: N.Invocation } : { arguments: t, target: e, type: N.Invocation }; { const r = this._invocationId; return this._invocationId++, 0 !== n.length ? { arguments: t, invocationId: r.toString(), streamIds: n, target: e, type: N.Invocation } : { arguments: t, invocationId: r.toString(), target: e, type: N.Invocation } } } _launchStreams(e, t) { if (0 !== e.length) { t || (t = Promise.resolve()); for (const r in e) e[r].subscribe({ complete: () => { t = t.then((() => this._sendWithProtocol(this._createCompletionMessage(r)))) }, error: e => { let n; n = e instanceof Error ? e.message : e && e.toString ? e.toString() : "Unknown error", t = t.then((() => this._sendWithProtocol(this._createCompletionMessage(r, n)))) }, next: e => { t = t.then((() => this._sendWithProtocol(this._createStreamItemMessage(r, e)))) } }) } } _replaceStreamingParams(e) { const t = [], r = []; for (let n = 0; n < e.length; n++) { const s = e[n]; if (this._isObservable(s)) { const o = this._invocationId; this._invocationId++, t[o] = s, r.push(o.toString()), e.splice(n, 1) } } return [t, r] } _isObservable(e) { return e && e.subscribe && "function" == typeof e.subscribe } _createStreamInvocation(e, t, r) { const n = this._invocationId; return this._invocationId++, 0 !== r.length ? { arguments: t, invocationId: n.toString(), streamIds: r, target: e, type: N.StreamInvocation } : { arguments: t, invocationId: n.toString(), target: e, type: N.StreamInvocation } } _createCancelInvocation(e) { return { invocationId: e, type: N.CancelInvocation } } _createStreamItemMessage(e, t) { return { invocationId: e, item: t, type: N.StreamItem } } _createCompletionMessage(e, t, r) { return t ? { error: t, invocationId: e, type: N.Completion } : { invocationId: e, result: r, type: N.Completion } } _createCloseMessage() { return { type: N.Close } } } class X { constructor() { this.name = "json", this.version = 2, this.transferFormat = j.Text } parseMessages(e, t) { if ("string" != typeof e) throw new Error("Invalid input for JSON hub protocol. Expected a string."); if (!e) return []; null === t && (t = b.instance); const r = V.parse(e), n = []; for (const e of r) { const r = JSON.parse(e); if ("number" != typeof r.type) throw new Error("Invalid payload."); switch (r.type) { case N.Invocation: this._isInvocationMessage(r); break; case N.StreamItem: this._isStreamItemMessage(r); break; case N.Completion: this._isCompletionMessage(r); break; case N.Ping: case N.Close: break; case N.Ack: this._isAckMessage(r); break; case N.Sequence: this._isSequenceMessage(r); break; default: t.log(v.Information, "Unknown message type '" + r.type + "' ignored."); continue }n.push(r) } return n } writeMessage(e) { return V.write(JSON.stringify(e)) } _isInvocationMessage(e) { this._assertNotEmptyString(e.target, "Invalid payload for Invocation message."), void 0 !== e.invocationId && this._assertNotEmptyString(e.invocationId, "Invalid payload for Invocation message.") } _isStreamItemMessage(e) { if (this._assertNotEmptyString(e.invocationId, "Invalid payload for StreamItem message."), void 0 === e.item) throw new Error("Invalid payload for StreamItem message.") } _isCompletionMessage(e) { if (e.result && e.error) throw new Error("Invalid payload for Completion message."); !e.result && e.error && this._assertNotEmptyString(e.error, "Invalid payload for Completion message."), this._assertNotEmptyString(e.invocationId, "Invalid payload for Completion message.") } _isAckMessage(e) { if ("number" != typeof e.sequenceId) throw new Error("Invalid SequenceId for Ack message.") } _isSequenceMessage(e) { if ("number" != typeof e.sequenceId) throw new Error("Invalid SequenceId for Sequence message.") } _assertNotEmptyString(e, t) { if ("string" != typeof e || "" === e) throw new Error(t) } } const ee = { trace: v.Trace, debug: v.Debug, info: v.Information, information: v.Information, warn: v.Warning, warning: v.Warning, error: v.Error, critical: v.Critical, none: v.None }; class te { configureLogging(e) { if (w.isRequired(e, "logging"), void 0 !== e.log) this.logger = e; else if ("string" == typeof e) { const t = function (e) { const t = ee[e.toLowerCase()]; if (void 0 !== t) return t; throw new Error(`Unknown log level: ${e}`) }(e); this.logger = new E(t) } else this.logger = new E(e); return this } withUrl(e, t) { return w.isRequired(e, "url"), w.isNotEmpty(e, "url"), this.url = e, this.httpConnectionOptions = "object" == typeof t ? { ...this.httpConnectionOptions, ...t } : { ...this.httpConnectionOptions, transport: t }, this } withHubProtocol(e) { return w.isRequired(e, "protocol"), this.protocol = e, this } withAutomaticReconnect(e) { if (this.reconnectPolicy) throw new Error("A reconnectPolicy has already been set."); return e ? Array.isArray(e) ? this.reconnectPolicy = new s(e) : this.reconnectPolicy = e : this.reconnectPolicy = new s, this } withServerTimeout(e) { return w.isRequired(e, "milliseconds"), this._serverTimeoutInMilliseconds = e, this } withKeepAliveInterval(e) { return w.isRequired(e, "milliseconds"), this._keepAliveIntervalInMilliseconds = e, this } withStatefulReconnect(e) { return void 0 === this.httpConnectionOptions && (this.httpConnectionOptions = {}), this.httpConnectionOptions._useStatefulReconnect = !0, this._statefulReconnectBufferSize = null == e ? void 0 : e.bufferSize, this } build() { const e = this.httpConnectionOptions || {}; if (void 0 === e.logger && (e.logger = this.logger), !this.url) throw new Error("The 'HubConnectionBuilder.withUrl' method must be called before building the connection."); const t = new W(this.url, e); return Z.create(t, this.logger || b.instance, this.protocol || new X, this.reconnectPolicy, this._serverTimeoutInMilliseconds, this._keepAliveIntervalInMilliseconds, this._statefulReconnectBufferSize) } } }, 2868: (e, t, r) => { e.exports = r(1867) }, 3155: (e, t, r) => { "use strict"; var n = r(4030), s = r(8079), o = r(4687), i = r(7512), a = r(9791), c = r(924), l = r(5903), d = r(5971); e.exports = function (e) { return new Promise((function (t, r) { var u = e.data, h = e.headers, p = e.responseType; n.isFormData(u) && delete h["Content-Type"]; var g = new XMLHttpRequest; if (e.auth) { var f = e.auth.username || "", m = e.auth.password ? unescape(encodeURIComponent(e.auth.password)) : ""; h.Authorization = "Basic " + btoa(f + ":" + m) } var v = a(e.baseURL, e.url); function b() { if (g) { var n = "getAllResponseHeaders" in g ? c(g.getAllResponseHeaders()) : null, o = { data: p && "text" !== p && "json" !== p ? g.response : g.responseText, status: g.status, statusText: g.statusText, headers: n, config: e, request: g }; s(t, r, o), g = null } } if (g.open(e.method.toUpperCase(), i(v, e.params, e.paramsSerializer), !0), g.timeout = e.timeout, "onloadend" in g ? g.onloadend = b : g.onreadystatechange = function () { g && 4 === g.readyState && (0 !== g.status || g.responseURL && 0 === g.responseURL.indexOf("file:")) && setTimeout(b) }, g.onabort = function () { g && (r(d("Request aborted", e, "ECONNABORTED", g)), g = null) }, g.onerror = function () { r(d("Network Error", e, null, g)), g = null }, g.ontimeout = function () { var t = "timeout of " + e.timeout + "ms exceeded"; e.timeoutErrorMessage && (t = e.timeoutErrorMessage), r(d(t, e, e.transitional && e.transitional.clarifyTimeoutError ? "ETIMEDOUT" : "ECONNABORTED", g)), g = null }, n.isStandardBrowserEnv()) { var _ = (e.withCredentials || l(v)) && e.xsrfCookieName ? o.read(e.xsrfCookieName) : void 0; _ && (h[e.xsrfHeaderName] = _) } "setRequestHeader" in g && n.forEach(h, (function (e, t) { void 0 === u && "content-type" === t.toLowerCase() ? delete h[t] : g.setRequestHeader(t, e) })), n.isUndefined(e.withCredentials) || (g.withCredentials = !!e.withCredentials), p && "json" !== p && (g.responseType = e.responseType), "function" == typeof e.onDownloadProgress && g.addEventListener("progress", e.onDownloadProgress), "function" == typeof e.onUploadProgress && g.upload && g.upload.addEventListener("progress", e.onUploadProgress), e.cancelToken && e.cancelToken.promise.then((function (e) { g && (g.abort(), r(e), g = null) })), u || (u = null), g.send(u) })) } }, 1867: (e, t, r) => { "use strict"; var n = r(4030), s = r(3843), o = r(5891), i = r(3316); function a(e) { var t = new o(e), r = s(o.prototype.request, t); return n.extend(r, o.prototype, t), n.extend(r, t), r } var c = a(r(457)); c.Axios = o, c.create = function (e) { return a(i(c.defaults, e)) }, c.Cancel = r(6266), c.CancelToken = r(9747), c.isCancel = r(9416), c.all = function (e) { return Promise.all(e) }, c.spread = r(1545), c.isAxiosError = r(232), e.exports = c, e.exports.default = c }, 6266: e => { "use strict"; function t(e) { this.message = e } t.prototype.toString = function () { return "Cancel" + (this.message ? ": " + this.message : "") }, t.prototype.__CANCEL__ = !0, e.exports = t }, 9747: (e, t, r) => { "use strict"; var n = r(6266); function s(e) { if ("function" != typeof e) throw new TypeError("executor must be a function."); var t; this.promise = new Promise((function (e) { t = e })); var r = this; e((function (e) { r.reason || (r.reason = new n(e), t(r.reason)) })) } s.prototype.throwIfRequested = function () { if (this.reason) throw this.reason }, s.source = function () { var e; return { token: new s((function (t) { e = t })), cancel: e } }, e.exports = s }, 9416: e => { "use strict"; e.exports = function (e) { return !(!e || !e.__CANCEL__) } }, 5891: (e, t, r) => { "use strict"; var n = r(4030), s = r(7512), o = r(8036), i = r(884), a = r(3316), c = r(9084), l = c.validators; function d(e) { this.defaults = e, this.interceptors = { request: new o, response: new o } } d.prototype.request = function (e) { "string" == typeof e ? (e = arguments[1] || {}).url = arguments[0] : e = e || {}, (e = a(this.defaults, e)).method ? e.method = e.method.toLowerCase() : this.defaults.method ? e.method = this.defaults.method.toLowerCase() : e.method = "get"; var t = e.transitional; void 0 !== t && c.assertOptions(t, { silentJSONParsing: l.transitional(l.boolean, "1.0.0"), forcedJSONParsing: l.transitional(l.boolean, "1.0.0"), clarifyTimeoutError: l.transitional(l.boolean, "1.0.0") }, !1); var r = [], n = !0; this.interceptors.request.forEach((function (t) { "function" == typeof t.runWhen && !1 === t.runWhen(e) || (n = n && t.synchronous, r.unshift(t.fulfilled, t.rejected)) })); var s, o = []; if (this.interceptors.response.forEach((function (e) { o.push(e.fulfilled, e.rejected) })), !n) { var d = [i, void 0]; for (Array.prototype.unshift.apply(d, r), d = d.concat(o), s = Promise.resolve(e); d.length;)s = s.then(d.shift(), d.shift()); return s } for (var u = e; r.length;) { var h = r.shift(), p = r.shift(); try { u = h(u) } catch (e) { p(e); break } } try { s = i(u) } catch (e) { return Promise.reject(e) } for (; o.length;)s = s.then(o.shift(), o.shift()); return s }, d.prototype.getUri = function (e) { return e = a(this.defaults, e), s(e.url, e.params, e.paramsSerializer).replace(/^\?/, "") }, n.forEach(["delete", "get", "head", "options"], (function (e) { d.prototype[e] = function (t, r) { return this.request(a(r || {}, { method: e, url: t, data: (r || {}).data })) } })), n.forEach(["post", "put", "patch"], (function (e) { d.prototype[e] = function (t, r, n) { return this.request(a(n || {}, { method: e, url: t, data: r })) } })), e.exports = d }, 8036: (e, t, r) => { "use strict"; var n = r(4030); function s() { this.handlers = [] } s.prototype.use = function (e, t, r) { return this.handlers.push({ fulfilled: e, rejected: t, synchronous: !!r && r.synchronous, runWhen: r ? r.runWhen : null }), this.handlers.length - 1 }, s.prototype.eject = function (e) { this.handlers[e] && (this.handlers[e] = null) }, s.prototype.forEach = function (e) { n.forEach(this.handlers, (function (t) { null !== t && e(t) })) }, e.exports = s }, 9791: (e, t, r) => { "use strict"; var n = r(957), s = r(7050); e.exports = function (e, t) { return e && !n(t) ? s(e, t) : t } }, 5971: (e, t, r) => { "use strict"; var n = r(3136); e.exports = function (e, t, r, s, o) { var i = new Error(e); return n(i, t, r, s, o) } }, 884: (e, t, r) => { "use strict"; var n = r(4030), s = r(8630), o = r(9416), i = r(457); function a(e) { e.cancelToken && e.cancelToken.throwIfRequested() } e.exports = function (e) { return a(e), e.headers = e.headers || {}, e.data = s.call(e, e.data, e.headers, e.transformRequest), e.headers = n.merge(e.headers.common || {}, e.headers[e.method] || {}, e.headers), n.forEach(["delete", "get", "head", "post", "put", "patch", "common"], (function (t) { delete e.headers[t] })), (e.adapter || i.adapter)(e).then((function (t) { return a(e), t.data = s.call(e, t.data, t.headers, e.transformResponse), t }), (function (t) { return o(t) || (a(e), t && t.response && (t.response.data = s.call(e, t.response.data, t.response.headers, e.transformResponse))), Promise.reject(t) })) } }, 3136: e => { "use strict"; e.exports = function (e, t, r, n, s) { return e.config = t, r && (e.code = r), e.request = n, e.response = s, e.isAxiosError = !0, e.toJSON = function () { return { message: this.message, name: this.name, description: this.description, number: this.number, fileName: this.fileName, lineNumber: this.lineNumber, columnNumber: this.columnNumber, stack: this.stack, config: this.config, code: this.code } }, e } }, 3316: (e, t, r) => { "use strict"; var n = r(4030); e.exports = function (e, t) { t = t || {}; var r = {}, s = ["url", "method", "data"], o = ["headers", "auth", "proxy", "params"], i = ["baseURL", "transformRequest", "transformResponse", "paramsSerializer", "timeout", "timeoutMessage", "withCredentials", "adapter", "responseType", "xsrfCookieName", "xsrfHeaderName", "onUploadProgress", "onDownloadProgress", "decompress", "maxContentLength", "maxBodyLength", "maxRedirects", "transport", "httpAgent", "httpsAgent", "cancelToken", "socketPath", "responseEncoding"], a = ["validateStatus"]; function c(e, t) { return n.isPlainObject(e) && n.isPlainObject(t) ? n.merge(e, t) : n.isPlainObject(t) ? n.merge({}, t) : n.isArray(t) ? t.slice() : t } function l(s) { n.isUndefined(t[s]) ? n.isUndefined(e[s]) || (r[s] = c(void 0, e[s])) : r[s] = c(e[s], t[s]) } n.forEach(s, (function (e) { n.isUndefined(t[e]) || (r[e] = c(void 0, t[e])) })), n.forEach(o, l), n.forEach(i, (function (s) { n.isUndefined(t[s]) ? n.isUndefined(e[s]) || (r[s] = c(void 0, e[s])) : r[s] = c(void 0, t[s]) })), n.forEach(a, (function (n) { n in t ? r[n] = c(e[n], t[n]) : n in e && (r[n] = c(void 0, e[n])) })); var d = s.concat(o).concat(i).concat(a), u = Object.keys(e).concat(Object.keys(t)).filter((function (e) { return -1 === d.indexOf(e) })); return n.forEach(u, l), r } }, 8079: (e, t, r) => { "use strict"; var n = r(5971); e.exports = function (e, t, r) { var s = r.config.validateStatus; r.status && s && !s(r.status) ? t(n("Request failed with status code " + r.status, r.config, null, r.request, r)) : e(r) } }, 8630: (e, t, r) => { "use strict"; var n = r(4030), s = r(457); e.exports = function (e, t, r) { var o = this || s; return n.forEach(r, (function (r) { e = r.call(o, e, t) })), e } }, 457: (e, t, r) => { "use strict"; var n = r(4030), s = r(7122), o = r(3136), i = { "Content-Type": "application/x-www-form-urlencoded" }; function a(e, t) { !n.isUndefined(e) && n.isUndefined(e["Content-Type"]) && (e["Content-Type"] = t) } var c, l = { transitional: { silentJSONParsing: !0, forcedJSONParsing: !0, clarifyTimeoutError: !1 }, adapter: (("undefined" != typeof XMLHttpRequest || "undefined" != typeof process && "[object process]" === Object.prototype.toString.call(process)) && (c = r(3155)), c), transformRequest: [function (e, t) { return s(t, "Accept"), s(t, "Content-Type"), n.isFormData(e) || n.isArrayBuffer(e) || n.isBuffer(e) || n.isStream(e) || n.isFile(e) || n.isBlob(e) ? e : n.isArrayBufferView(e) ? e.buffer : n.isURLSearchParams(e) ? (a(t, "application/x-www-form-urlencoded;charset=utf-8"), e.toString()) : n.isObject(e) || t && "application/json" === t["Content-Type"] ? (a(t, "application/json"), function (e, t, r) { if (n.isString(e)) try { return (0, JSON.parse)(e), n.trim(e) } catch (e) { if ("SyntaxError" !== e.name) throw e } return (0, JSON.stringify)(e) }(e)) : e }], transformResponse: [function (e) { var t = this.transitional, r = t && t.silentJSONParsing, s = t && t.forcedJSONParsing, i = !r && "json" === this.responseType; if (i || s && n.isString(e) && e.length) try { return JSON.parse(e) } catch (e) { if (i) { if ("SyntaxError" === e.name) throw o(e, this, "E_JSON_PARSE"); throw e } } return e }], timeout: 0, xsrfCookieName: "XSRF-TOKEN", xsrfHeaderName: "X-XSRF-TOKEN", maxContentLength: -1, maxBodyLength: -1, validateStatus: function (e) { return e >= 200 && e < 300 }, headers: { common: { Accept: "application/json, text/plain, */*" } } }; n.forEach(["delete", "get", "head"], (function (e) { l.headers[e] = {} })), n.forEach(["post", "put", "patch"], (function (e) { l.headers[e] = n.merge(i) })), e.exports = l }, 3843: e => { "use strict"; e.exports = function (e, t) { return function () { for (var r = new Array(arguments.length), n = 0; n < r.length; n++)r[n] = arguments[n]; return e.apply(t, r) } } }, 7512: (e, t, r) => { "use strict"; var n = r(4030); function s(e) { return encodeURIComponent(e).replace(/%3A/gi, ":").replace(/%24/g, "$").replace(/%2C/gi, ",").replace(/%20/g, "+").replace(/%5B/gi, "[").replace(/%5D/gi, "]") } e.exports = function (e, t, r) { if (!t) return e; var o; if (r) o = r(t); else if (n.isURLSearchParams(t)) o = t.toString(); else { var i = []; n.forEach(t, (function (e, t) { null != e && (n.isArray(e) ? t += "[]" : e = [e], n.forEach(e, (function (e) { n.isDate(e) ? e = e.toISOString() : n.isObject(e) && (e = JSON.stringify(e)), i.push(s(t) + "=" + s(e)) }))) })), o = i.join("&") } if (o) { var a = e.indexOf("#"); -1 !== a && (e = e.slice(0, a)), e += (-1 === e.indexOf("?") ? "?" : "&") + o } return e } }, 7050: e => { "use strict"; e.exports = function (e, t) { return t ? e.replace(/\/+$/, "") + "/" + t.replace(/^\/+/, "") : e } }, 4687: (e, t, r) => { "use strict"; var n = r(4030); e.exports = n.isStandardBrowserEnv() ? { write: function (e, t, r, s, o, i) { var a = []; a.push(e + "=" + encodeURIComponent(t)), n.isNumber(r) && a.push("expires=" + new Date(r).toGMTString()), n.isString(s) && a.push("path=" + s), n.isString(o) && a.push("domain=" + o), !0 === i && a.push("secure"), document.cookie = a.join("; ") }, read: function (e) { var t = document.cookie.match(new RegExp("(^|;\\s*)(" + e + ")=([^;]*)")); return t ? decodeURIComponent(t[3]) : null }, remove: function (e) { this.write(e, "", Date.now() - 864e5) } } : { write: function () { }, read: function () { return null }, remove: function () { } } }, 957: e => { "use strict"; e.exports = function (e) { return /^([a-z][a-z\d\+\-\.]*:)?\/\//i.test(e) } }, 232: e => { "use strict"; e.exports = function (e) { return "object" == typeof e && !0 === e.isAxiosError } }, 5903: (e, t, r) => { "use strict"; var n = r(4030); e.exports = n.isStandardBrowserEnv() ? function () { var e, t = /(msie|trident)/i.test(navigator.userAgent), r = document.createElement("a"); function s(e) { var n = e; return t && (r.setAttribute("href", n), n = r.href), r.setAttribute("href", n), { href: r.href, protocol: r.protocol ? r.protocol.replace(/:$/, "") : "", host: r.host, search: r.search ? r.search.replace(/^\?/, "") : "", hash: r.hash ? r.hash.replace(/^#/, "") : "", hostname: r.hostname, port: r.port, pathname: "/" === r.pathname.charAt(0) ? r.pathname : "/" + r.pathname } } return e = s(window.location.href), function (t) { var r = n.isString(t) ? s(t) : t; return r.protocol === e.protocol && r.host === e.host } }() : function () { return !0 } }, 7122: (e, t, r) => { "use strict"; var n = r(4030); e.exports = function (e, t) { n.forEach(e, (function (r, n) { n !== t && n.toUpperCase() === t.toUpperCase() && (e[t] = r, delete e[n]) })) } }, 924: (e, t, r) => { "use strict"; var n = r(4030), s = ["age", "authorization", "content-length", "content-type", "etag", "expires", "from", "host", "if-modified-since", "if-unmodified-since", "last-modified", "location", "max-forwards", "proxy-authorization", "referer", "retry-after", "user-agent"]; e.exports = function (e) { var t, r, o, i = {}; return e ? (n.forEach(e.split("\n"), (function (e) { if (o = e.indexOf(":"), t = n.trim(e.substr(0, o)).toLowerCase(), r = n.trim(e.substr(o + 1)), t) { if (i[t] && s.indexOf(t) >= 0) return; i[t] = "set-cookie" === t ? (i[t] ? i[t] : []).concat([r]) : i[t] ? i[t] + ", " + r : r } })), i) : i } }, 1545: e => { "use strict"; e.exports = function (e) { return function (t) { return e.apply(null, t) } } }, 9084: (e, t, r) => { "use strict"; var n = r(8593), s = {};["object", "boolean", "number", "function", "string", "symbol"].forEach((function (e, t) { s[e] = function (r) { return typeof r === e || "a" + (t < 1 ? "n " : " ") + e } })); var o = {}, i = n.version.split("."); function a(e, t) { for (var r = t ? t.split(".") : i, n = e.split("."), s = 0; s < 3; s++) { if (r[s] > n[s]) return !0; if (r[s] < n[s]) return !1 } return !1 } s.transitional = function (e, t, r) { var s = t && a(t); function i(e, t) { return "[Axios v" + n.version + "] Transitional option '" + e + "'" + t + (r ? ". " + r : "") } return function (r, n, a) { if (!1 === e) throw new Error(i(n, " has been removed in " + t)); return s && !o[n] && (o[n] = !0, console.warn(i(n, " has been deprecated since v" + t + " and will be removed in the near future"))), !e || e(r, n, a) } }, e.exports = { isOlderVersion: a, assertOptions: function (e, t, r) { if ("object" != typeof e) throw new TypeError("options must be an object"); for (var n = Object.keys(e), s = n.length; s-- > 0;) { var o = n[s], i = t[o]; if (i) { var a = e[o], c = void 0 === a || i(a, o, e); if (!0 !== c) throw new TypeError("option " + o + " must be " + c) } else if (!0 !== r) throw Error("Unknown option " + o) } }, validators: s } }, 4030: (e, t, r) => { "use strict"; var n = r(3843), s = Object.prototype.toString; function o(e) { return "[object Array]" === s.call(e) } function i(e) { return void 0 === e } function a(e) { return null !== e && "object" == typeof e } function c(e) { if ("[object Object]" !== s.call(e)) return !1; var t = Object.getPrototypeOf(e); return null === t || t === Object.prototype } function l(e) { return "[object Function]" === s.call(e) } function d(e, t) { if (null != e) if ("object" != typeof e && (e = [e]), o(e)) for (var r = 0, n = e.length; r < n; r++)t.call(null, e[r], r, e); else for (var s in e) Object.prototype.hasOwnProperty.call(e, s) && t.call(null, e[s], s, e) } e.exports = { isArray: o, isArrayBuffer: function (e) { return "[object ArrayBuffer]" === s.call(e) }, isBuffer: function (e) { return null !== e && !i(e) && null !== e.constructor && !i(e.constructor) && "function" == typeof e.constructor.isBuffer && e.constructor.isBuffer(e) }, isFormData: function (e) { return "undefined" != typeof FormData && e instanceof FormData }, isArrayBufferView: function (e) { return "undefined" != typeof ArrayBuffer && ArrayBuffer.isView ? ArrayBuffer.isView(e) : e && e.buffer && e.buffer instanceof ArrayBuffer }, isString: function (e) { return "string" == typeof e }, isNumber: function (e) { return "number" == typeof e }, isObject: a, isPlainObject: c, isUndefined: i, isDate: function (e) { return "[object Date]" === s.call(e) }, isFile: function (e) { return "[object File]" === s.call(e) }, isBlob: function (e) { return "[object Blob]" === s.call(e) }, isFunction: l, isStream: function (e) { return a(e) && l(e.pipe) }, isURLSearchParams: function (e) { return "undefined" != typeof URLSearchParams && e instanceof URLSearchParams }, isStandardBrowserEnv: function () { return ("undefined" == typeof navigator || "ReactNative" !== navigator.product && "NativeScript" !== navigator.product && "NS" !== navigator.product) && "undefined" != typeof window && "undefined" != typeof document }, forEach: d, merge: function e() { var t = {}; function r(r, n) { c(t[n]) && c(r) ? t[n] = e(t[n], r) : c(r) ? t[n] = e({}, r) : o(r) ? t[n] = r.slice() : t[n] = r } for (var n = 0, s = arguments.length; n < s; n++)d(arguments[n], r); return t }, extend: function (e, t, r) { return d(t, (function (t, s) { e[s] = r && "function" == typeof t ? n(t, r) : t })), e }, trim: function (e) { return e.trim ? e.trim() : e.replace(/^\s+|\s+$/g, "") }, stripBOM: function (e) { return 65279 === e.charCodeAt(0) && (e = e.slice(1)), e } } }, 2218: (e, t, r) => { "use strict"; var n = r(4836), s = r(6597), o = r(8346), i = r(1236), a = r(2423); (e.exports = function (e, t) { var r, s, c, l, d; return arguments.length < 2 || "string" != typeof e ? (l = t, t = e, e = null) : l = arguments[2], n(e) ? (r = a.call(e, "c"), s = a.call(e, "e"), c = a.call(e, "w")) : (r = c = !0, s = !1), d = { value: t, configurable: r, enumerable: s, writable: c }, l ? o(i(l), d) : d }).gs = function (e, t, r) { var c, l, d, u; return "string" != typeof e ? (d = r, r = t, t = e, e = null) : d = arguments[3], n(t) ? s(t) ? n(r) ? s(r) || (d = r, r = void 0) : r = void 0 : (d = t, t = r = void 0) : t = void 0, n(e) ? (c = a.call(e, "c"), l = a.call(e, "e")) : (c = !0, l = !1), u = { get: t, set: r, configurable: c, enumerable: l }, d ? o(i(d), u) : u } }, 7322: function (e) { e.exports = function () { "use strict"; var e = 6e4, t = 36e5, r = "millisecond", n = "second", s = "minute", o = "hour", i = "day", a = "week", c = "month", l = "quarter", d = "year", u = "date", h = "Invalid Date", p = /^(\d{4})[-/]?(\d{1,2})?[-/]?(\d{0,2})[Tt\s]*(\d{1,2})?:?(\d{1,2})?:?(\d{1,2})?[.:]?(\d+)?$/, g = /\[([^\]]+)]|Y{1,4}|M{1,4}|D{1,2}|d{1,4}|H{1,2}|h{1,2}|a|A|m{1,2}|s{1,2}|Z{1,2}|SSS/g, f = { name: "en", weekdays: "Sunday_Monday_Tuesday_Wednesday_Thursday_Friday_Saturday".split("_"), months: "January_February_March_April_May_June_July_August_September_October_November_December".split("_"), ordinal: function (e) { var t = ["th", "st", "nd", "rd"], r = e % 100; return "[" + e + (t[(r - 20) % 10] || t[r] || t[0]) + "]" } }, m = function (e, t, r) { var n = String(e); return !n || n.length >= t ? e : "" + Array(t + 1 - n.length).join(r) + e }, v = { s: m, z: function (e) { var t = -e.utcOffset(), r = Math.abs(t), n = Math.floor(r / 60), s = r % 60; return (t <= 0 ? "+" : "-") + m(n, 2, "0") + ":" + m(s, 2, "0") }, m: function e(t, r) { if (t.date() < r.date()) return -e(r, t); var n = 12 * (r.year() - t.year()) + (r.month() - t.month()), s = t.clone().add(n, c), o = r - s < 0, i = t.clone().add(n + (o ? -1 : 1), c); return +(-(n + (r - s) / (o ? s - i : i - s)) || 0) }, a: function (e) { return e < 0 ? Math.ceil(e) || 0 : Math.floor(e) }, p: function (e) { return { M: c, y: d, w: a, d: i, D: u, h: o, m: s, s: n, ms: r, Q: l }[e] || String(e || "").toLowerCase().replace(/s$/, "") }, u: function (e) { return void 0 === e } }, b = "en", _ = {}; _[b] = f; var w = function (e) { return e instanceof k }, y = function e(t, r, n) { var s; if (!t) return b; if ("string" == typeof t) { var o = t.toLowerCase(); _[o] && (s = o), r && (_[o] = r, s = o); var i = t.split("-"); if (!s && i.length > 1) return e(i[0]) } else { var a = t.name; _[a] = t, s = a } return !n && s && (b = s), s || !n && b }, S = function (e, t) { if (w(e)) return e.clone(); var r = "object" == typeof t ? t : {}; return r.date = e, r.args = arguments, new k(r) }, x = v; x.l = y, x.i = w, x.w = function (e, t) { return S(e, { locale: t.$L, utc: t.$u, x: t.$x, $offset: t.$offset }) }; var k = function () { function f(e) { this.$L = y(e.locale, null, !0), this.parse(e) } var m = f.prototype; return m.parse = function (e) { this.$d = function (e) { var t = e.date, r = e.utc; if (null === t) return new Date(NaN); if (x.u(t)) return new Date; if (t instanceof Date) return new Date(t); if ("string" == typeof t && !/Z$/i.test(t)) { var n = t.match(p); if (n) { var s = n[2] - 1 || 0, o = (n[7] || "0").substring(0, 3); return r ? new Date(Date.UTC(n[1], s, n[3] || 1, n[4] || 0, n[5] || 0, n[6] || 0, o)) : new Date(n[1], s, n[3] || 1, n[4] || 0, n[5] || 0, n[6] || 0, o) } } return new Date(t) }(e), this.$x = e.x || {}, this.init() }, m.init = function () { var e = this.$d; this.$y = e.getFullYear(), this.$M = e.getMonth(), this.$D = e.getDate(), this.$W = e.getDay(), this.$H = e.getHours(), this.$m = e.getMinutes(), this.$s = e.getSeconds(), this.$ms = e.getMilliseconds() }, m.$utils = function () { return x }, m.isValid = function () { return !(this.$d.toString() === h) }, m.isSame = function (e, t) { var r = S(e); return this.startOf(t) <= r && r <= this.endOf(t) }, m.isAfter = function (e, t) { return S(e) < this.startOf(t) }, m.isBefore = function (e, t) { return this.endOf(t) < S(e) }, m.$g = function (e, t, r) { return x.u(e) ? this[t] : this.set(r, e) }, m.unix = function () { return Math.floor(this.valueOf() / 1e3) }, m.valueOf = function () { return this.$d.getTime() }, m.startOf = function (e, t) { var r = this, l = !!x.u(t) || t, h = x.p(e), p = function (e, t) { var n = x.w(r.$u ? Date.UTC(r.$y, t, e) : new Date(r.$y, t, e), r); return l ? n : n.endOf(i) }, g = function (e, t) { return x.w(r.toDate()[e].apply(r.toDate("s"), (l ? [0, 0, 0, 0] : [23, 59, 59, 999]).slice(t)), r) }, f = this.$W, m = this.$M, v = this.$D, b = "set" + (this.$u ? "UTC" : ""); switch (h) { case d: return l ? p(1, 0) : p(31, 11); case c: return l ? p(1, m) : p(0, m + 1); case a: var _ = this.$locale().weekStart || 0, w = (f < _ ? f + 7 : f) - _; return p(l ? v - w : v + (6 - w), m); case i: case u: return g(b + "Hours", 0); case o: return g(b + "Minutes", 1); case s: return g(b + "Seconds", 2); case n: return g(b + "Milliseconds", 3); default: return this.clone() } }, m.endOf = function (e) { return this.startOf(e, !1) }, m.$set = function (e, t) { var a, l = x.p(e), h = "set" + (this.$u ? "UTC" : ""), p = (a = {}, a[i] = h + "Date", a[u] = h + "Date", a[c] = h + "Month", a[d] = h + "FullYear", a[o] = h + "Hours", a[s] = h + "Minutes", a[n] = h + "Seconds", a[r] = h + "Milliseconds", a)[l], g = l === i ? this.$D + (t - this.$W) : t; if (l === c || l === d) { var f = this.clone().set(u, 1); f.$d[p](g), f.init(), this.$d = f.set(u, Math.min(this.$D, f.daysInMonth())).$d } else p && this.$d[p](g); return this.init(), this }, m.set = function (e, t) { return this.clone().$set(e, t) }, m.get = function (e) { return this[x.p(e)]() }, m.add = function (r, l) { var u, h = this; r = Number(r); var p = x.p(l), g = function (e) { var t = S(h); return x.w(t.date(t.date() + Math.round(e * r)), h) }; if (p === c) return this.set(c, this.$M + r); if (p === d) return this.set(d, this.$y + r); if (p === i) return g(1); if (p === a) return g(7); var f = (u = {}, u[s] = e, u[o] = t, u[n] = 1e3, u)[p] || 1, m = this.$d.getTime() + r * f; return x.w(m, this) }, m.subtract = function (e, t) { return this.add(-1 * e, t) }, m.format = function (e) { var t = this, r = this.$locale(); if (!this.isValid()) return r.invalidDate || h; var n = e || "YYYY-MM-DDTHH:mm:ssZ", s = x.z(this), o = this.$H, i = this.$m, a = this.$M, c = r.weekdays, l = r.months, d = r.meridiem, u = function (e, r, s, o) { return e && (e[r] || e(t, n)) || s[r].slice(0, o) }, p = function (e) { return x.s(o % 12 || 12, e, "0") }, f = d || function (e, t, r) { var n = e < 12 ? "AM" : "PM"; return r ? n.toLowerCase() : n }; return n.replace(g, (function (e, n) { return n || function (e) { switch (e) { case "YY": return String(t.$y).slice(-2); case "YYYY": return x.s(t.$y, 4, "0"); case "M": return a + 1; case "MM": return x.s(a + 1, 2, "0"); case "MMM": return u(r.monthsShort, a, l, 3); case "MMMM": return u(l, a); case "D": return t.$D; case "DD": return x.s(t.$D, 2, "0"); case "d": return String(t.$W); case "dd": return u(r.weekdaysMin, t.$W, c, 2); case "ddd": return u(r.weekdaysShort, t.$W, c, 3); case "dddd": return c[t.$W]; case "H": return String(o); case "HH": return x.s(o, 2, "0"); case "h": return p(1); case "hh": return p(2); case "a": return f(o, i, !0); case "A": return f(o, i, !1); case "m": return String(i); case "mm": return x.s(i, 2, "0"); case "s": return String(t.$s); case "ss": return x.s(t.$s, 2, "0"); case "SSS": return x.s(t.$ms, 3, "0"); case "Z": return s }return null }(e) || s.replace(":", "") })) }, m.utcOffset = function () { return 15 * -Math.round(this.$d.getTimezoneOffset() / 15) }, m.diff = function (r, u, h) { var p, g = this, f = x.p(u), m = S(r), v = (m.utcOffset() - this.utcOffset()) * e, b = this - m, _ = function () { return x.m(g, m) }; switch (f) { case d: p = _() / 12; break; case c: p = _(); break; case l: p = _() / 3; break; case a: p = (b - v) / 6048e5; break; case i: p = (b - v) / 864e5; break; case o: p = b / t; break; case s: p = b / e; break; case n: p = b / 1e3; break; default: p = b }return h ? p : x.a(p) }, m.daysInMonth = function () { return this.endOf(c).$D }, m.$locale = function () { return _[this.$L] }, m.locale = function (e, t) { if (!e) return this.$L; var r = this.clone(), n = y(e, t, !0); return n && (r.$L = n), r }, m.clone = function () { return x.w(this.$d, this) }, m.toDate = function () { return new Date(this.valueOf()) }, m.toJSON = function () { return this.isValid() ? this.toISOString() : null }, m.toISOString = function () { return this.$d.toISOString() }, m.toString = function () { return this.$d.toUTCString() }, f }(), C = k.prototype; return S.prototype = C, [["$ms", r], ["$s", n], ["$m", s], ["$H", o], ["$W", i], ["$M", c], ["$y", d], ["$D", u]].forEach((function (e) { C[e[1]] = function (t) { return this.$g(t, e[0], e[1]) } })), S.extend = function (e, t) { return e.$i || (e(t, k, S), e.$i = !0), S }, S.locale = y, S.isDayjs = w, S.unix = function (e) { return S(1e3 * e) }, S.en = _[b], S.Ls = _, S.p = {}, S }() }, 7060: function (e) { e.exports = function () { "use strict"; return function (e, t, r) { var n = "h:mm A", s = { lastDay: "[Yesterday at] " + n, sameDay: "[Today at] " + n, nextDay: "[Tomorrow at] " + n, nextWeek: "dddd [at] " + n, lastWeek: "[Last] dddd [at] " + n, sameElse: "MM/DD/YYYY" }; t.prototype.calendar = function (e, t) { var n = t || this.$locale().calendar || s, o = r(e || void 0).startOf("d"), i = this.diff(o, "d", !0), a = "sameElse", c = i < -6 ? a : i < -1 ? "lastWeek" : i < 0 ? "lastDay" : i < 1 ? "sameDay" : i < 2 ? "nextDay" : i < 7 ? "nextWeek" : a, l = n[c] || s[c]; return "function" == typeof l ? l.call(this, r()) : this.format(l) } } }() }, 3954: function (e) { e.exports = function () { "use strict"; return function (e, t, r) { e = e || {}; var n = t.prototype, s = { future: "in %s", past: "%s ago", s: "a few seconds", m: "a minute", mm: "%d minutes", h: "an hour", hh: "%d hours", d: "a day", dd: "%d days", M: "a month", MM: "%d months", y: "a year", yy: "%d years" }; function o(e, t, r, s) { return n.fromToBase(e, t, r, s) } r.en.relativeTime = s, n.fromToBase = function (t, n, o, i, a) { for (var c, l, d, u = o.$locale().relativeTime || s, h = e.thresholds || [{ l: "s", r: 44, d: "second" }, { l: "m", r: 89 }, { l: "mm", r: 44, d: "minute" }, { l: "h", r: 89 }, { l: "hh", r: 21, d: "hour" }, { l: "d", r: 35 }, { l: "dd", r: 25, d: "day" }, { l: "M", r: 45 }, { l: "MM", r: 10, d: "month" }, { l: "y", r: 17 }, { l: "yy", d: "year" }], p = h.length, g = 0; g < p; g += 1) { var f = h[g]; f.d && (c = i ? r(t).diff(o, f.d, !0) : o.diff(t, f.d, !0)); var m = (e.rounding || Math.round)(Math.abs(c)); if (d = c > 0, m <= f.r || !f.r) { m <= 1 && g > 0 && (f = h[g - 1]); var v = u[f.l]; a && (m = a("" + m)), l = "string" == typeof v ? v.replace("%d", m) : v(m, n, f.l, d); break } } if (n) return l; var b = d ? u.future : u.past; return "function" == typeof b ? b(l) : b.replace("%s", l) }, n.to = function (e, t) { return o(e, t, this, !0) }, n.from = function (e, t) { return o(e, t, this) }; var i = function (e) { return e.$u ? r.utc() : r() }; n.toNow = function (e) { return this.to(i(this), e) }, n.fromNow = function (e) { return this.from(i(this), e) } } }() }, 8155: e => { "use strict"; e.exports = function () { } }, 8346: (e, t, r) => { "use strict"; e.exports = r(6667)() ? Object.assign : r(676) }, 6667: e => { "use strict"; e.exports = function () { var e, t = Object.assign; return "function" == typeof t && (t(e = { foo: "raz" }, { bar: "dwa" }, { trzy: "trzy" }), e.foo + e.bar + e.trzy === "razdwatrzy") } }, 676: (e, t, r) => { "use strict"; var n = r(1827), s = r(713), o = Math.max; e.exports = function (e, t) { var r, i, a, c = o(arguments.length, 2); for (e = Object(s(e)), a = function (n) { try { e[n] = t[n] } catch (e) { r || (r = e) } }, i = 1; i < c; ++i)n(t = arguments[i]).forEach(a); if (void 0 !== r) throw r; return e } }, 8230: (e, t, r) => { "use strict"; var n = r(7606), s = { function: !0, object: !0 }; e.exports = function (e) { return n(e) && s[typeof e] || !1 } }, 7606: (e, t, r) => { "use strict"; var n = r(8155)(); e.exports = function (e) { return e !== n && null !== e } }, 1827: (e, t, r) => { "use strict"; e.exports = r(4431)() ? Object.keys : r(618) }, 4431: e => { "use strict"; e.exports = function () { try { return Object.keys("primitive"), !0 } catch (e) { return !1 } } }, 618: (e, t, r) => { "use strict"; var n = r(7606), s = Object.keys; e.exports = function (e) { return s(n(e) ? Object(e) : e) } }, 1236: (e, t, r) => { "use strict"; var n = r(7606), s = Array.prototype.forEach, o = Object.create; e.exports = function (e) { var t = o(null); return s.call(arguments, (function (e) { n(e) && function (e, t) { var r; for (r in e) t[r] = e[r] }(Object(e), t) })), t } }, 2157: e => { "use strict"; e.exports = function (e) { if ("function" != typeof e) throw new TypeError(e + " is not a function"); return e } }, 5848: (e, t, r) => { "use strict"; var n = r(8230); e.exports = function (e) { if (!n(e)) throw new TypeError(e + " is not an Object"); return e } }, 713: (e, t, r) => { "use strict"; var n = r(7606); e.exports = function (e) { if (!n(e)) throw new TypeError("Cannot use null or undefined"); return e } }, 2423: (e, t, r) => { "use strict"; e.exports = r(4941)() ? String.prototype.contains : r(3143) }, 4941: e => { "use strict"; var t = "razdwatrzy"; e.exports = function () { return "function" == typeof t.contains && !0 === t.contains("dwa") && !1 === t.contains("foo") } }, 3143: e => { "use strict"; var t = String.prototype.indexOf; e.exports = function (e) { return t.call(this, e, arguments[1]) > -1 } }, 2928: (e, t, r) => { "use strict"; var n = r(5848), s = Object.prototype.hasOwnProperty; e.exports = function (e) { var t, r = arguments[1]; if (n(e), void 0 === r) s.call(e, "__ee__") && delete e.__ee__; else { if (!(t = s.call(e, "__ee__") && e.__ee__)) return; t[r] && delete t[r] } } }, 8611: (e, t, r) => { "use strict"; var n, s, o, i, a, c, l, d = r(2218), u = r(2157), h = Function.prototype.apply, p = Function.prototype.call, g = Object.create, f = Object.defineProperty, m = Object.defineProperties, v = Object.prototype.hasOwnProperty, b = { configurable: !0, enumerable: !1, writable: !0 }; s = function (e, t) { var r, s; return u(t), s = this, n.call(this, e, r = function () { o.call(s, e, r), h.call(t, this, arguments) }), r.__eeOnceListener__ = t, this }, a = { on: n = function (e, t) { var r; return u(t), v.call(this, "__ee__") ? r = this.__ee__ : (r = b.value = g(null), f(this, "__ee__", b), b.value = null), r[e] ? "object" == typeof r[e] ? r[e].push(t) : r[e] = [r[e], t] : r[e] = t, this }, once: s, off: o = function (e, t) { var r, n, s, o; if (u(t), !v.call(this, "__ee__")) return this; if (!(r = this.__ee__)[e]) return this; if ("object" == typeof (n = r[e])) for (o = 0; s = n[o]; ++o)s !== t && s.__eeOnceListener__ !== t || (2 === n.length ? r[e] = n[o ? 0 : 1] : n.splice(o, 1)); else n !== t && n.__eeOnceListener__ !== t || delete r[e]; return this }, emit: i = function (e) { var t, r, n, s, o; if (v.call(this, "__ee__") && (s = this.__ee__[e])) if ("object" == typeof s) { for (r = arguments.length, o = new Array(r - 1), t = 1; t < r; ++t)o[t - 1] = arguments[t]; for (s = s.slice(), t = 0; n = s[t]; ++t)h.call(n, this, o) } else switch (arguments.length) { case 1: p.call(s, this); break; case 2: p.call(s, this, arguments[1]); break; case 3: p.call(s, this, arguments[1], arguments[2]); break; default: for (r = arguments.length, o = new Array(r - 1), t = 1; t < r; ++t)o[t - 1] = arguments[t]; h.call(s, this, o) } } }, c = { on: d(n), once: d(s), off: d(o), emit: d(i) }, l = m({}, c), e.exports = t = function (e) { return null == e ? g(l) : m(Object(e), c) }, t.methods = a }, 6815: (e, t, r) => { "use strict"; var n = r(8333); e.exports = function (e) { if ("function" != typeof e) return !1; if (!hasOwnProperty.call(e, "length")) return !1; try { if ("number" != typeof e.length) return !1; if ("function" != typeof e.call) return !1; if ("function" != typeof e.apply) return !1 } catch (e) { return !1 } return !n(e) } }, 1232: (e, t, r) => { "use strict"; var n = r(4836), s = { object: !0, function: !0, undefined: !0 }; e.exports = function (e) { return !!n(e) && hasOwnProperty.call(s, typeof e) } }, 6597: (e, t, r) => { "use strict"; var n = r(6815), s = /^\s*class[\s{/}]/, o = Function.prototype.toString; e.exports = function (e) { return !!n(e) && !s.test(o.call(e)) } }, 8333: (e, t, r) => { "use strict"; var n = r(1232); e.exports = function (e) { if (!n(e)) return !1; try { return !!e.constructor && e.constructor.prototype === e } catch (e) { return !1 } } }, 4836: e => { "use strict"; e.exports = function (e) { return null != e } }, 9702: (e, t, r) => { "use strict"; Object.defineProperty(t, "__esModule", { value: !0 }), t.replaceGradientCssClass = t.replaceBackdropCssClass = t.gradientClassPicker = t.backdropClassPicker = void 0; const n = r(7114), s = ["backdrop-1", "backdrop-2", "backdrop-3", "backdrop-4"], o = ["gradient-purple", "gradient-red-purple", "gradient-blue", "gradient-pink-blue", "gradient-aqua", "gradient-neon-green"], i = e => t => { const r = (0, n.stringMod)(t.substring(Math.min(2, e.length)), e.length); return e[r] }; t.backdropClassPicker = e => "diamonddixie" === e.toLowerCase() ? s[0] : i(s)(e), t.gradientClassPicker = i(o); const a = e => (t, r) => { null == t || t.classList.remove(...e), null == t || t.classList.add(r) }; t.replaceBackdropCssClass = a(s), t.replaceGradientCssClass = a(o) }, 890: (e, t) => { "use strict"; Object.defineProperty(t, "__esModule", { value: !0 }), t.BLANK_IMG = t.streamingTextImageURL = t.streamerNameImageURL = t.streamerPortraitImageURL = void 0, t.streamerPortraitImageURL = e => `https://assets.livespins.com/room-events/raw/${e}.png`, t.streamerNameImageURL = e => `https://assets.livespins.com/streamers/streamer-name-${e}.png`, t.streamingTextImageURL = (e, t) => t && ["de", "es", "fr", "id", "ja", "pt", "th", "vi", "zh", "it", "tr", "ru", "no", "ko", "fi"].includes(t.toLocaleLowerCase()) ? `https://assets.livespins.com/streamers/streaming-${e}-${t.toLowerCase()}.png` : `https://assets.livespins.com/streamers/streaming-${e}.png`, t.BLANK_IMG = "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAQAAAC1HAwCAAAAC0lEQVR42mNkYAAAAAYAAjCB0C8AAAAASUVORK5CYII=" }, 2198: (e, t) => { "use strict"; Object.defineProperty(t, "__esModule", { value: !0 }), t.languageMappingGet = t.languageMappingSet = void 0; let r, n = {}; const s = new Promise((e => { r = e })); t.languageMappingSet = e => { n = { ...e }, r({ ...n }) }, t.languageMappingGet = () => s }, 5005: (e, t) => { "use strict"; Object.defineProperty(t, "__esModule", { value: !0 }), t.buildEventImageURL = t.parseEventUIData = t.linearGradient = void 0, t.linearGradient = e => `linear-gradient(237.81deg, rgba(32, 32, 39, 0) 30.68%, ${e} 100%)`, t.parseEventUIData = e => { try { const t = JSON.parse(e); if (t.eventColor && t.eventFileName) return t } catch (e) { return null } }, t.buildEventImageURL = e => `https://assets.livespins.com/room-events/raw/events/${e}` }, 9758: function (e, t, r) { "use strict"; var n = this && this.__importDefault || function (e) { return e && e.__esModule ? e : { default: e } }; Object.defineProperty(t, "__esModule", { value: !0 }); const s = r(9702), o = r(890), i = r(2198), a = r(3854), c = r(1086), l = r(4882), d = r(2735), u = r(1904), h = r(5005), p = n(r(8550)), g = n(r(8611)), f = n(r(2928)); let m; void 0 !== document.hidden ? m = "hidden" : void 0 !== document.msHidden ? m = "msHidden" : void 0 !== document.webkitHidden && (m = "webkitHidden"); const v = "ON_RESIZE"; class b extends HTMLElement { constructor() { var e, t, r, n, s, o; super(), this.disposeFunctions = [], this.width = 0; const i = this.attachShadow({ mode: "open" }); i.innerHTML = p.default, this.emitter = (0, g.default)(), this.translations = (0, u.loadLanguageData)("en"), this.disposeFunctions.push((() => { (0, f.default)(this.emitter) })), ResizeObserver && i && (this.resizeObserver = new ResizeObserver((([e]) => { this.width = e.contentRect.width, this.emitter.emit(v, { width: this.width }) })), this.resizeObserver.observe(this), this.disposeFunctions.push((() => { var e; null === (e = this.resizeObserver) || void 0 === e || e.disconnect() }))), this.streamThumbnailElement = null === (e = this.shadowRoot) || void 0 === e ? void 0 : e.querySelector('[data-target="stream-thumbnail"]'), this.viewersBadgeElement = null === (t = this.shadowRoot) || void 0 === t ? void 0 : t.querySelector('[data-target="viewers-badge"]'), this.placeholderLayersElements = Array.from((null === (r = this.shadowRoot) || void 0 === r ? void 0 : r.querySelectorAll('[data-target="layer-placeholder"]')) || []), this.patternLayer = null === (n = this.shadowRoot) || void 0 === n ? void 0 : n.querySelector('[data-target="pattern-layer"]'), this.eventOverlayTintElement = null === (s = this.shadowRoot) || void 0 === s ? void 0 : s.querySelector(".event-overlay-tint"), this.streamerPlaceholder = null === (o = this.shadowRoot) || void 0 === o ? void 0 : o.querySelector('[data-target="streamer-placeholder"]') } async updateTranslationsKeys(e, t) { e.forEach((e => { var r; const n = t[e] || e, s = null === (r = this.shadowRoot) || void 0 === r ? void 0 : r.querySelector(`[data-i18n="${e}"]`); s && s.dataset.i18n === e && n && (s.innerHTML = n) })) } connectedCallback() { var e, t, r, n, s, o; if ((0, a.registerLivespinsRoomElement)(this), this.disposeFunctions.push((() => { (0, a.unregisterLivespinsRoomElement)(this) })), (0, c.get)("cta") || "true" === this.getAttribute("cta") || "" === this.getAttribute("cta")) { const s = new CustomEvent("livespins-navigate", { detail: { sessionId: this.getAttribute("id") || this.getAttribute("sessionId") } }); this.onclick = () => { document.dispatchEvent(s) }, null === (t = null === (e = this.shadowRoot) || void 0 === e ? void 0 : e.querySelector(".container > .wrapper")) || void 0 === t || t.classList.add("clickable"), null === (n = null === (r = this.shadowRoot) || void 0 === r ? void 0 : r.querySelector(".cta-container")) || void 0 === n || n.classList.remove("display-none") } else null === (o = null === (s = this.shadowRoot) || void 0 === s ? void 0 : s.querySelector(".cta-container")) || void 0 === o || o.classList.add("display-none"); this.emitter.on(v, (({ width: e }) => { var t, r, n, s; e < Math.floor(196) ? null === (r = null === (t = this.shadowRoot) || void 0 === t ? void 0 : t.querySelector(".container")) || void 0 === r || r.classList.add("small-view") : null === (s = null === (n = this.shadowRoot) || void 0 === n ? void 0 : n.querySelector(".container")) || void 0 === s || s.classList.remove("small-view") })), this.streamThumbnailElement && new IntersectionObserver(((e, t) => { const [r] = e; r.isIntersecting && (this.refreshStreamThumbnail(), t.unobserve(r.target)) }), { root: null, threshold: .5 }).observe(this.streamThumbnailElement) } refreshStreamThumbnail() { if (!this.streamThumbnailElement) return; this.streamThumbnailElement.onload = () => { this.showThumbnail() }, this.streamThumbnailElement.onerror = () => { this.hideThumbnail() }; const e = () => { const e = this.getAttribute("thumbnail"); e && fetch(e).then((e => e.blob())).then((e => { var t; null === (t = this.streamThumbnailElement) || void 0 === t || t.setAttribute("src", URL.createObjectURL(e)) })) }; e(); const t = setInterval(e, 6e4); this.disposeFunctions.push((() => { clearInterval(t) })) } disconnectedCallback() { this.disposeFunctions.forEach((e => e())) } static get observedAttributes() { return ["streamernickname", "streamerid", "maxplayers", "totalplayersinbetbehind", "language", "content-language", "locale", "day", "time", "viewers", "currentgame", "currentgametitle", "ispast", "issinglestream", "metadata", "cta", "istesting", "thumbnail"] } updateAttr(e, t) { var r; const n = null === (r = this.shadowRoot) || void 0 === r ? void 0 : r.querySelector(`[data-bind="${e}"]`); n && n.dataset.bind === e && t && (n.innerHTML = t) } showThumbnail() { var e, t, r, n; null === (e = this.patternLayer) || void 0 === e || e.classList.remove("hide"), null === (t = this.eventOverlayTintElement) || void 0 === t || t.classList.remove("hide"), null === (r = this.placeholderLayersElements) || void 0 === r || r.forEach((e => e.classList.add("hide"))), null === (n = this.streamerPlaceholder) || void 0 === n || n.classList.add("hide") } hideThumbnail() { var e, t, r, n; null === (e = this.patternLayer) || void 0 === e || e.classList.add("hide"), null === (t = this.eventOverlayTintElement) || void 0 === t || t.classList.add("hide"), null === (r = this.placeholderLayersElements) || void 0 === r || r.forEach((e => e.classList.remove("hide"))), null === (n = this.streamerPlaceholder) || void 0 === n || n.classList.remove("hide") } attributeChangedCallback(e, t, r) { var n, a, c, p, g, f, m, v, b, _, w, y, S, x, k, C, E, A, T, I; switch (e) { case "streamernickname": this.updateAttr(e, (0, d.streamerNameFormatter)(r)); break; case "streamerid": { const e = null === (n = this.shadowRoot) || void 0 === n ? void 0 : n.querySelector(".container"), t = (0, s.backdropClassPicker)(r || "default"); e && (0, s.replaceBackdropCssClass)(e, t); const i = (0, l.getStreamerImageFileName)(r); null === (c = null === (a = this.shadowRoot) || void 0 === a ? void 0 : a.querySelector('[data-target="streamer-image-placeholder"]')) || void 0 === c || c.setAttribute("src", (0, o.streamerPortraitImageURL)(i || (0, l.pickRandomDefaultImageFileName)(r))), null === (g = null === (p = this.shadowRoot) || void 0 === p ? void 0 : p.querySelector('[data-target="streaming-image-placeholder"]')) || void 0 === g || g.setAttribute("src", (0, o.streamingTextImageURL)(t, this.getAttribute("locale") || "en")); const d = null === (f = this.shadowRoot) || void 0 === f ? void 0 : f.querySelector(".footer"); i ? (null === (v = null === (m = this.shadowRoot) || void 0 === m ? void 0 : m.querySelector('[data-target="streamer-name-image-placeholder"]')) || void 0 === v || v.setAttribute("src", (0, o.streamerNameImageURL)(i)), d.classList.add("hide")) : (null === (_ = null === (b = this.shadowRoot) || void 0 === b ? void 0 : b.querySelector('[data-target="streamer-name-image-placeholder"]')) || void 0 === _ || _.setAttribute("src", o.BLANK_IMG), d.classList.remove("hide")); break } case "locale": { const e = this.getAttribute("locale"); this.translations = (0, u.loadLanguageData)(e || "en"), e && this.updateTranslationsKeys(["playing", "play_now", "live"], this.translations); const t = (0, o.streamingTextImageURL)((0, s.backdropClassPicker)(this.getAttribute("streamerid") || "default"), e || "en"); null === (y = null === (w = this.shadowRoot) || void 0 === w ? void 0 : w.querySelector('[data-target="streaming-image-placeholder"]')) || void 0 === y || y.setAttribute("src", t); break } case "language": this.getAttribute("content-language") || (0, i.languageMappingGet)().then((t => { this.updateAttr(e, t[r].englishName) })); break; case "content-language": this.updateAttr("language", this.getAttribute("content-language") || ""); break; case "metadata": { const e = null === (S = this.shadowRoot) || void 0 === S ? void 0 : S.querySelector(".event-overlay-tint"), t = null === (x = this.shadowRoot) || void 0 === x ? void 0 : x.querySelector('[data-target="layer-events"]'), n = null === (k = this.shadowRoot) || void 0 === k ? void 0 : k.querySelector('[data-target="stream-event-image-placeholder"]'), s = null === (C = this.shadowRoot) || void 0 === C ? void 0 : C.querySelectorAll(".streaming-image-content"), o = null === (E = this.shadowRoot) || void 0 === E ? void 0 : E.querySelector(".footer"), i = (0, h.parseEventUIData)(r); if (!i) return s.forEach((e => e.classList.remove("hide"))), t.classList.add("hide"), e.classList.add("hide"), void (e.style.background = ""); s.forEach((e => e.classList.add("hide"))), t.classList.remove("hide"), o.classList.add("hide"), e.style.background = (0, h.linearGradient)(i.eventColor), n.setAttribute("src", (0, h.buildEventImageURL)(i.eventFileName)); break } case "istesting": if ("true" === r || "" === r) { const e = null === (A = this.shadowRoot) || void 0 === A ? void 0 : A.querySelector(".container"); null == e || e.classList.add("isTesting") } break; case "viewers": Number(r) < 50 ? null === (T = this.viewersBadgeElement) || void 0 === T || T.classList.add("display-none") : (null === (I = this.viewersBadgeElement) || void 0 === I || I.classList.remove("display-none"), this.updateAttr(e, r)); break; default: this.updateAttr(e, r) } } } void 0 === window.customElements.get("livespins-room") && window.customElements.define("livespins-room", b) }, 7265: function (e, t, r) { "use strict"; var n = this && this.__importDefault || function (e) { return e && e.__esModule ? e : { default: e } }; Object.defineProperty(t, "__esModule", { value: !0 }); const s = r(9702), o = r(890), i = r(5005), a = r(4882), c = r(2735), l = r(1904), d = n(r(7618)), u = n(r(7322)), h = n(r(8611)), p = n(r(2928)), g = "ON_RESIZE"; class f extends HTMLElement { constructor() { super(), this.disposeFunctions = [], this.width = 0; const e = this.attachShadow({ mode: "open" }); e.innerHTML = d.default, this.emitter = (0, h.default)(), this.translations = (0, l.loadLanguageData)("en"), this.disposeFunctions.push((() => { (0, p.default)(this.emitter) })), ResizeObserver && e && (this.resizeObserver = new ResizeObserver((([e]) => { this.width = e.contentRect.width, this.emitter.emit(g, { width: this.width }) })), this.resizeObserver.observe(this), this.disposeFunctions.push((() => { var e; null === (e = this.resizeObserver) || void 0 === e || e.disconnect() }))) } updateAttr(e, t) { var r; const n = null === (r = this.shadowRoot) || void 0 === r ? void 0 : r.querySelector(`[data-bind="${e}"]`); n && n.dataset.bind === e && t && (n.innerHTML = t) } updateTranslation(e, t) { var r; const n = null === (r = this.shadowRoot) || void 0 === r ? void 0 : r.querySelector(`[data-i18n="${e}"]`); n && n.dataset.i18n === e && t && (n.innerHTML = t) } formatStreamStartingTime(e) { const t = (0, u.default)(Date.now()), r = (0, u.default)(e), n = r.diff(t, "minute"); let s = ""; if (r.diff(t, "second") < 10 && ("true" === this.getAttribute("autoremove") || "" === this.getAttribute("autoremove")) && this.remove(), n < 60) s = this.translations.in_x_minutes.replace("{number}", String(n)), n < 1 && (s = this.translations.now); else { const t = this.translations.at, r = this.translations.tomorrow; s = (0, u.default)(e).calendar(null, { sameDay: `[${t}] h:mm A`, nextDay: `[${r} ${t}] h:mm A`, nextWeek: `dddd [${t}] h:mm A`, sameElse: `DD MMM [${t}] h:mm A` }) } return s } attributeChangedCallback(e, t, r) { var n, d, u, h, p, g, f, m, v, b, _, w, y, S, x, k, C; switch (e) { case "date": { const t = this.formatStreamStartingTime(r); this.updateAttr(e, t), this.refreshInterval || (this.refreshInterval = setInterval((() => { const t = this.formatStreamStartingTime(r); this.updateAttr(e, t) }), 1e4)); break } case "streamer": this.updateAttr(e, (0, c.streamerNameFormatter)(r)); break; case "streamerid": { const e = null === (n = this.shadowRoot) || void 0 === n ? void 0 : n.querySelector(".container"), t = (0, s.backdropClassPicker)(r || "default"); e && (0, s.replaceBackdropCssClass)(e, t); const i = (0, a.getStreamerImageFileName)(r); null === (u = null === (d = this.shadowRoot) || void 0 === d ? void 0 : d.querySelector('[data-target="streamer-image-placeholder"]')) || void 0 === u || u.setAttribute("src", (0, o.streamerPortraitImageURL)(i || (0, a.pickRandomDefaultImageFileName)(r))), null === (p = null === (h = this.shadowRoot) || void 0 === h ? void 0 : h.querySelector('[data-target="streaming-image-placeholder"]')) || void 0 === p || p.setAttribute("src", (0, o.streamingTextImageURL)(t, this.getAttribute("locale") || "en")), i && (null === (f = null === (g = this.shadowRoot) || void 0 === g ? void 0 : g.querySelector('[data-target="streamer-name-image-placeholder"]')) || void 0 === f || f.setAttribute("src", (0, o.streamerNameImageURL)(i))); break } case "metadata": { const e = null === (m = this.shadowRoot) || void 0 === m ? void 0 : m.querySelector(".overlay-tint"), t = null === (v = this.shadowRoot) || void 0 === v ? void 0 : v.querySelector('[data-target="layer-events"]'), n = null === (b = this.shadowRoot) || void 0 === b ? void 0 : b.querySelector('[data-target="stream-event-image-placeholder"]'), s = null === (_ = this.shadowRoot) || void 0 === _ ? void 0 : _.querySelectorAll(".streaming-image-content"), o = (0, i.parseEventUIData)(r); if (!o) return t.classList.add("hide"), void s.forEach((e => e.classList.remove("hide"))); s.forEach((e => e.classList.add("hide"))), e.classList.remove("hide"), t.classList.remove("hide"), n.setAttribute("src", (0, i.buildEventImageURL)(o.eventFileName)); break } case "cta": "true" === r || "" === r ? null === (y = null === (w = this.shadowRoot) || void 0 === w ? void 0 : w.querySelector(".cta-container")) || void 0 === y || y.classList.remove("display-none") : null === (x = null === (S = this.shadowRoot) || void 0 === S ? void 0 : S.querySelector(".cta-container")) || void 0 === x || x.classList.add("display-none"); break; case "locale": case "isNextStream": { const e = this.getAttribute("locale"); this.translations = (0, l.loadLanguageData)(e || "en"), e && (this.updateTranslationsKeys(["later", "starts"], this.translations), "true" === this.getAttribute("isNextStream") && this.updateTranslation("later", this.translations.up_next)); const t = (0, o.streamingTextImageURL)((0, s.backdropClassPicker)(this.getAttribute("streamerid") || "default"), e || "en"); null === (C = null === (k = this.shadowRoot) || void 0 === k ? void 0 : k.querySelector('[data-target="streaming-image-placeholder"]')) || void 0 === C || C.setAttribute("src", t); break } case "content-language": this.updateAttr("language", this.getAttribute("content-language") || ""); break; default: this.updateAttr(e, r) } } async updateTranslationsKeys(e, t) { e.forEach((e => { const r = t[e] || e; this.updateTranslation(e, r) })) } connectedCallback() { this.emitter.on(g, (({ width: e }) => { var t, r, n, s; e < Math.floor(196) ? null === (r = null === (t = this.shadowRoot) || void 0 === t ? void 0 : t.querySelector(".container")) || void 0 === r || r.classList.add("small-view") : null === (s = null === (n = this.shadowRoot) || void 0 === n ? void 0 : n.querySelector(".container")) || void 0 === s || s.classList.remove("small-view") })) } disconnectedCallback() { clearInterval(this.refreshInterval), this.disposeFunctions.forEach((e => e())) } static get observedAttributes() { return ["autoremove", "content-language", "cta", "date", "id", "isnextstream", "language", "locale", "metadata", "streamer", "streamerid"] } } void 0 === window.customElements.get("livespins-schedule-room") && window.customElements.define("livespins-schedule-room", f) }, 4494: function (e, t, r) { "use strict"; var n = this && this.__importDefault || function (e) { return e && e.__esModule ? e : { default: e } }; Object.defineProperty(t, "__esModule", { value: !0 }); const s = r(9702), o = r(890), i = r(4882), a = r(2735), c = n(r(2374)); class l extends HTMLElement { constructor() { super(), this.attachShadow({ mode: "open" }).innerHTML = c.default } updateAttr(e, t) { var r; const n = null === (r = this.shadowRoot) || void 0 === r ? void 0 : r.querySelector(`[data-bind="${e}"]`); n && n.dataset.bind === e && t && (n.innerHTML = t) } attributeChangedCallback(e, t, r) { var n, c, l; switch (e) { case "name": { const t = (e => { const [t, ...r] = e; return [t.toUpperCase(), ...r].join("") })((0, a.streamerNameFormatter)(r)); this.updateAttr(e, t); break } case "streamerid": { const e = null === (n = this.shadowRoot) || void 0 === n ? void 0 : n.querySelector(".container"); if (e) { const t = (0, s.gradientClassPicker)(r || "default"); (0, s.replaceBackdropCssClass)(e, t) } const t = (0, i.getStreamerImageFileName)(r) || (0, i.pickRandomDefaultImageFileName)(r); null === (l = null === (c = this.shadowRoot) || void 0 === c ? void 0 : c.querySelector('[data-target="streamer-image-placeholder"]')) || void 0 === l || l.setAttribute("src", (0, o.streamerPortraitImageURL)(t)); break } } } static get observedAttributes() { return ["name", "streamerid"] } } void 0 === window.customElements.get("livespins-streamer") && window.customElements.define("livespins-streamer", l) }, 3854: (e, t, r) => { "use strict"; Object.defineProperty(t, "__esModule", { value: !0 }), t.MonitorSelectedLivespinsRoomPlugin = t.unregisterLivespinsRoomElement = t.registerLivespinsRoomElement = void 0; const n = r(475); let s = null; const o = new Map, i = "sessionid", a = e => `LS.monitor-selected-plugin.${e}`, c = a("request-for-session-id"), l = a("clear-selected-session-id"), d = a("clear-selected-session-id"), u = (e, t = 0) => { var r; if (5 === t) return null; const n = null === (r = e.parentElement) || void 0 === r ? void 0 : r.querySelectorAll("livespins-room"); return n ? n.length > 1 ? null : 0 === n.length ? e.parentElement ? u(e.parentElement, t++) : null : 1 === n.length ? n[0] : null : null }, h = e => { if (null === e.target) return; if (e.target.nodeType !== Node.ELEMENT_NODE) return; const t = e.target; for (const e of o.values()) if (e.contains(t)) return void (s = e.getAttribute(i)); const r = u(t); r && (s = r.getAttribute(i)) }, p = e => { var t; if ("https://play.livespins.com" !== e.origin) return; const r = (0, n.tryCatch)((() => JSON.parse(e.data)), (() => ({}))); r.type === c && (null === (t = e.source) || void 0 === t || t.postMessage(JSON.stringify({ selectedSessionId: s, type: l }), { targetOrigin: "*" })), r.type === d && (s = null) }; t.registerLivespinsRoomElement = e => o.set(e, e), t.unregisterLivespinsRoomElement = e => o.delete(e), t.MonitorSelectedLivespinsRoomPlugin = class { startup() { document.addEventListener("click", h), window.addEventListener("message", p) } teardown() { document.addEventListener("click", h), window.removeEventListener("message", p), s = null, o.clear() } } }, 4182: (e, t) => { "use strict"; Object.defineProperty(t, "__esModule", { value: !0 }), t.noopPlugin = t.NoopPlugin = void 0; class r { startup() { } teardown() { } } t.NoopPlugin = r, t.noopPlugin = new r }, 1086: (e, t) => { "use strict"; Object.defineProperty(t, "__esModule", { value: !0 }), t.set = t.get = void 0; const r = {}; t.get = e => r[e], t.set = (e, t) => r[e] = t }, 4882: (e, t, r) => { "use strict"; Object.defineProperty(t, "__esModule", { value: !0 }), t.livespinsStreamerNames = t.pickRandomDefaultImageFileName = t.getStreamerImageFileName = t.DEFAULT_4 = t.DEFAULT_3 = t.DEFAULT_2 = t.DEFAULT_1 = void 0; const n = r(7114); t.DEFAULT_1 = "default-1", t.DEFAULT_2 = "default-2", t.DEFAULT_3 = "default-3", t.DEFAULT_4 = "default-4"; const s = [t.DEFAULT_1, t.DEFAULT_2, t.DEFAULT_3, t.DEFAULT_4], o = ["bb8cb6ac-acf4-55e9-a5c7-84541ace7afd", "dcbed2c7-757c-41d2-98e9-a0943e5f7889", "33dbb6d6-49a7-45c2-a679-d21a40cbb635", "3edb9ad3-de46-4477-a63d-6cdac1c2c608", "88d737d2-31bb-4962-aa3d-3fb824122f16", "ab59b6a4-c93a-4df5-9f72-df28cbe42137", "33f0f83d-d2b0-474a-b927-61722cae9a46", "df512d3c-f4ef-4038-83ef-30bf801b4ded", "49cb6e6c-66bd-4494-851f-4a128dcfaf24", "d04832b7-d638-4eaa-b5f7-534d8e3d3abd", "1c60edf1-5152-4dfb-b17d-85231490ffe0", "b9508bec-901e-4e2f-840a-1d48f50cd82b", "35c61d9e-d09c-4763-861d-5a1193d17641", "51b933f0-93c2-4a5c-bc3f-d06ef05d810b", "d4af3c70-d1a8-476d-ad38-fcfced09cc57", "68e9ae07-eab0-475e-9e67-cd21257d6235", "81fdd63d-7c8b-4810-80e2-4d7722efb5e4", "1a887439-ffd0-46a9-8f16-257fcf2b6504", "6e45c488-0e14-4152-a9ba-2716aee31204", "7af63e00-4ecc-4c73-994a-930d327a1db5", "10dd3fec-d92b-43de-9e26-f572387eecbd", "c5bb5550-f096-475e-9bb2-17a0c67d0235", "0ac92bdf-d97f-4df4-97b4-5a7e8604cba0", "149654e2-d26d-4f00-9c23-4b8aa6b0dcb8", "4d7c00ac-0c5f-4557-a88b-e3e6e36c5e59", "f9aa9c93-75b7-49f8-b89f-8fa2904fb74b", "7f7d8e6c-7e8d-4335-bd0d-5d2f715defc1", "26c0b5df-15f5-42bf-afd7-5914c97570a5", "48a241e7-9238-40c9-bdf1-0dc1a8cb6e57", "d9a264ce-74ac-492d-988e-4b995078ba10", "6fb9f3d7-bfc0-418b-912b-6c9a64594454", "999b21f9-4510-4906-accb-031f1685c29e", "ec98975f-2763-4675-8aab-245e5b069dea", "bbd14077-1180-4da4-8ac8-b1d45f72ade7", "192660c6-0207-4711-8f4a-c82dcdfd4cf8", "6ed70db2-26d8-4d20-8905-03949aa5dd7f", "ef171a7d-e829-41e0-862d-c44f7a47fca8", "e46d88e9-bc8b-44e9-be24-9dfc0fad112f", "482ea12b-a6dd-403d-ad3b-6e988b30dcdb", "1eb9aed7-2d96-4596-acb6-1674a0f652f7", "f5171a0e-6790-410d-82b6-c3179ee3904c", "b1af6fa0-4976-4d01-94a2-bc599230867a", "e98dbeaf-961c-4816-b2a1-70d104cbd8c0", "cfd8a157-3db2-4731-bf56-01480ba33e17", "43f204fe-bead-4b4a-b62e-51d0bb04e76c", "338ee845-c8d5-4711-8953-a913b219d288", "487c1b43-9da3-490b-9f0d-341a703fb0b7", "0c738640-8d0c-492f-a33e-b76e189c2901", "2ebb1509-3ba5-4aac-8d5a-93739bda5a0b", "96bcc2e6-22d3-40d0-9ebd-fbca9657f63d", "ed9943bf-4ae8-4430-a893-cae7599940aa", "cba60b53-6b77-4e04-b227-31466df4ecf9", "0e66d82f-a99c-5fb3-8c6e-4f923d3cbbb5", "fa9d42c0-333c-48dd-b65f-0a25d5b14286", "bbdf71fd-a21f-4a75-b45a-b4ef57aab99c", "f55710af-a652-4537-90fe-bcdc5a882aa6", "4ab6cb8d-f5b7-4aae-beb5-1d4725f9792f", "f6f0f833-068c-4fd8-ada5-7712f61e2a28", "1c73284e-b137-4349-845b-695071cece92", "2406a288-faab-493b-b9aa-796d4e235add", "a25d84d8-0f32-40f6-b106-f8b8fe166686", "8c4932a7-7a81-49ec-85bd-ff0abce0192b", "0aa8bb8a-4fb3-4447-a964-9e0786f515b2", "387d4020-85a3-4bc8-ad3c-c37d747111b9", "4c3bd179-bbf5-4b26-be67-fb3dc10206d9", "b7ed5f74-d805-4bcb-abe6-123b9643e119", "79cbbcf6-a053-4795-a11b-f5af27f0b287", "aacc1190-925d-4fff-8c56-ae74822c6df8", "fa0987ba-9e29-4c45-bcee-088c0b04784a", "f0754a22-5e0b-47f5-89bd-f06fe6449f48", "f737b5d2-7acb-47b1-a8fe-9b0f191699d6", "84a98159-2914-44e4-85d8-7ee02954d481"], i = ["d416aa78-960b-443c-b239-97514f47280b", "a564c67d-5b64-4fe7-b24b-aa3912db11aa", ...o]; t.getStreamerImageFileName = e => { const t = i.indexOf(e); return t >= 0 ? i[t] : null }, t.pickRandomDefaultImageFileName = e => { const t = (0, n.stringMod)(e, s.length); return s[t] }, t.livespinsStreamerNames = () => [...o].reverse() }, 2735: (e, t) => { "use strict"; Object.defineProperty(t, "__esModule", { value: !0 }), t.streamerNameFormatter = void 0; const r = { bobbybillions: "Bobby Billions", captainmitch: "Captain Mitch", zoozix: "ZoOzix", aion: "AION", grsten: "GrsTen", crazychaz: "Crazy Chaz", apexmilkman: "Apex Milkman", larsvegas: "Lars Vegas", diamonddixie: "Diamond Dixie", maryjay: "Mary Jay", hashtag_maryjay: "Hash & Marj", champb: "ChampB" }; t.streamerNameFormatter = e => r[e.toLowerCase()] || e }, 7114: (e, t) => { "use strict"; Object.defineProperty(t, "__esModule", { value: !0 }), t.stringMod = void 0, t.stringMod = (e, t) => { const r = [...e].map((e => e.charCodeAt(0))).reduce(((e, t) => e + t)); return Math.abs(r % t) } }, 6199: (e, t, r) => { "use strict"; Object.defineProperty(t, "__esModule", { value: !0 }), t.createConvertors = void 0; const n = r(2498); t.createConvertors = e => ({ toPlayURL: (0, n.generatePlayURLFactory)(e), toLobbyURL: (0, n.generateLobbyURLFactory)(e), toLivespinsRoom: e => { throw "Not Yet Implemented" }, toLivespinsScheduleRoom: e => { throw "Not Yet Implemented" } }) }, 8156: function (e, t, r) { "use strict"; var n, s, o, i, a, c, l = this && this.__classPrivateFieldSet || function (e, t, r, n, s) { if ("m" === n) throw new TypeError("Private method is not writable"); if ("a" === n && !s) throw new TypeError("Private accessor was defined without a setter"); if ("function" == typeof t ? e !== t || !s : !t.has(e)) throw new TypeError("Cannot write private member to an object whose class did not declare it"); return "a" === n ? s.call(e, r) : s ? s.value = r : t.set(e, r), r }, d = this && this.__classPrivateFieldGet || function (e, t, r, n) { if ("a" === r && !n) throw new TypeError("Private accessor was defined without a getter"); if ("function" == typeof t ? e !== t || !n : !t.has(e)) throw new TypeError("Cannot read private member from an object whose class did not declare it"); return "m" === r ? n : "a" === r ? n.call(e) : n ? n.value : t.get(e) }, u = this && this.__importDefault || function (e) { return e && e.__esModule ? e : { default: e } }; Object.defineProperty(t, "__esModule", { value: !0 }), t.HTTPConnectionManager = void 0; const h = r(6559), p = u(r(9029)); t.HTTPConnectionManager = class { constructor(e, t) { n.set(this, !1), s.set(this, 6e4), o.set(this, 0), i.set(this, void 0), a.set(this, void 0), c.set(this, void 0), l(this, a, e, "f"), l(this, c, t, "f"), l(this, i, new h.LivespinsAPI(new URL(d(this, a, "f").getServerConfig().api).origin, d(this, a, "f").getTenant()), "f") } async stop() { clearInterval(d(this, o, "f")), l(this, n, !1, "f") } async tick() { const [e, t] = await Promise.all([d(this, i, "f").sessions(), d(this, i, "f").schedule()]); d(this, c, "f").clearStreams(), e.forEach((e => d(this, c, "f").handleLivespinsMessage({ type: "StreamerSessionUpdatedThrottled", message: e }))), d(this, c, "f").clearScheduledStreams(), d(this, c, "f").handleLivespinsMessage({ type: "PrimitiveScheduleUpdated", message: t }) } async start() { d(this, n, "f") && d(this, o, "f") >= 0 ? p.default.log("Already connected.") : (d(this, c, "f").handleLanguageMessages({ type: "Languages", message: { list: await d(this, i, "f").language() } }), await this.tick(), l(this, o, setInterval((() => { this.tick() }), d(this, s, "f")), "f"), l(this, n, !0, "f")) } isConnected() { return d(this, n, "f") } async reconnect() { await this.start() } }, n = new WeakMap, s = new WeakMap, o = new WeakMap, i = new WeakMap, a = new WeakMap, c = new WeakMap }, 6559: function (e, t, r) { "use strict"; var n, s, o = this && this.__classPrivateFieldSet || function (e, t, r, n, s) { if ("m" === n) throw new TypeError("Private method is not writable"); if ("a" === n && !s) throw new TypeError("Private accessor was defined without a setter"); if ("function" == typeof t ? e !== t || !s : !t.has(e)) throw new TypeError("Cannot write private member to an object whose class did not declare it"); return "a" === n ? s.call(e, r) : s ? s.value = r : t.set(e, r), r }, i = this && this.__classPrivateFieldGet || function (e, t, r, n) { if ("a" === r && !n) throw new TypeError("Private accessor was defined without a getter"); if ("function" == typeof t ? e !== t || !n : !t.has(e)) throw new TypeError("Cannot read private member from an object whose class did not declare it"); return "m" === r ? n : "a" === r ? n.call(e) : n ? n.value : t.get(e) }, a = this && this.__importDefault || function (e) { return e && e.__esModule ? e : { default: e } }; Object.defineProperty(t, "__esModule", { value: !0 }), t.LivespinsAPI = void 0; const c = a(r(2868)); t.LivespinsAPI = class { constructor(e, t) { n.set(this, void 0), s.set(this, void 0), o(this, n, t, "f"), o(this, s, c.default.create({ baseURL: e }), "f") } async sessions() { return (await i(this, s, "f").get(`livespins/v1/sessions/${i(this, n, "f")}`)).data } async schedule() { return (await i(this, s, "f").get(`livespins/v1/schedule/${i(this, n, "f")}`)).data } async language() { return (await i(this, s, "f").get("livespins/v1/languages")).data } }, n = new WeakMap, s = new WeakMap }, 1065: function (e, t, r) { "use strict"; var n, s, o, i = this && this.__classPrivateFieldSet || function (e, t, r, n, s) { if ("m" === n) throw new TypeError("Private method is not writable"); if ("a" === n && !s) throw new TypeError("Private accessor was defined without a setter"); if ("function" == typeof t ? e !== t || !s : !t.has(e)) throw new TypeError("Cannot write private member to an object whose class did not declare it"); return "a" === n ? s.call(e, r) : s ? s.value = r : t.set(e, r), r }, a = this && this.__classPrivateFieldGet || function (e, t, r, n) { if ("a" === r && !n) throw new TypeError("Private accessor was defined without a getter"); if ("function" == typeof t ? e !== t || !n : !t.has(e)) throw new TypeError("Cannot read private member from an object whose class did not declare it"); return "m" === r ? n : "a" === r ? n.call(e) : n ? n.value : t.get(e) }, c = this && this.__importDefault || function (e) { return e && e.__esModule ? e : { default: e } }; Object.defineProperty(t, "__esModule", { value: !0 }), t.Client = void 0; const l = r(1230), d = c(r(7322)), u = c(r(8611)), h = "UPDATE"; t.Client = class { constructor(e, t) { n.set(this, void 0), s.set(this, void 0), o.set(this, void 0), i(this, n, e, "f"), i(this, s, (0, u.default)(), "f"), i(this, o, t, "f"), a(this, n, "f").onStreamAdded((() => { a(this, s, "f").emit(h) })), a(this, n, "f").onStreamUpdated((() => { a(this, s, "f").emit(h) })), a(this, n, "f").onStreamDeleted((() => { a(this, s, "f").emit(h) })), a(this, n, "f").onScheduleUpdated((() => { a(this, s, "f").emit(h) })) } onUpdate(e) { const t = (0, l.debounce)(e); return a(this, s, "f").on(h, t), () => { a(this, s, "f").off(h, t) } } getStreams() { return p([...a(this, n, "f").getStreams()], { language: a(this, o, "f").getLanguage() }).map((e => { const t = a(this, n, "f").getSupportedLanguagesById(), r = a(this, n, "f").getSupportedLanguages(); let s; return s = t[e.language], s || (s = r.find((t => t.alpha3 === e.language))), s ? { ...e, "content-language": s.englishName, locale: a(this, o, "f").getLanguage() } : { ...e, "content-language": "Unknown Language" } })) } getScheduledStreams() { return [...a(this, n, "f").getScheduledStreams()].filter((e => d.default.unix(e.scheduledStartTime).isAfter((0, d.default)()))).map((e => { const t = a(this, n, "f").getSupportedLanguagesById(), r = a(this, n, "f").getSupportedLanguages(); let s; return e.language && (s = t[e.language] || t[e.language.toLowerCase()]), s || (s = r.find((t => t.alpha3 === e.language))), s ? { ...e, "content-language": s.englishName, locale: a(this, o, "f").getLanguage() } : { ...e, "content-language": "Unknown Language" } })) } getStreamers() { return [...a(this, n, "f").getStreamers()] } getSupportedLanguages() { return [...a(this, n, "f").getSupportedLanguages()] } }, n = new WeakMap, s = new WeakMap, o = new WeakMap; const p = (e, { language: t }) => e.sort(((e, r) => { const n = e.language.toLowerCase(), s = r.language.toLowerCase(); return n !== s ? s === t.toLowerCase() ? 1 : -1 : e.order !== r.order ? e.order - r.order : r.startTimestamp - e.startTimestamp })) }, 9819: function (e, t, r) { "use strict"; var n, s, o, i, a, c, l = this && this.__classPrivateFieldSet || function (e, t, r, n, s) { if ("m" === n) throw new TypeError("Private method is not writable"); if ("a" === n && !s) throw new TypeError("Private accessor was defined without a setter"); if ("function" == typeof t ? e !== t || !s : !t.has(e)) throw new TypeError("Cannot write private member to an object whose class did not declare it"); return "a" === n ? s.call(e, r) : s ? s.value = r : t.set(e, r), r }, d = this && this.__classPrivateFieldGet || function (e, t, r, n) { if ("a" === r && !n) throw new TypeError("Private accessor was defined without a getter"); if ("function" == typeof t ? e !== t || !n : !t.has(e)) throw new TypeError("Cannot read private member from an object whose class did not declare it"); return "m" === r ? n : "a" === r ? n.call(e) : n ? n.value : t.get(e) }; Object.defineProperty(t, "__esModule", { value: !0 }), t.sdk = void 0; const u = r(3854), h = r(4182), p = r(6199), g = r(8156), f = r(1065), m = r(864), v = r(9488), b = r(8763); class _ { constructor(e) { var t; this.documentation = "https://docs.livespins.com/javascript-sdk/", this.version = "0.2.170", n.set(this, void 0), s.set(this, void 0), o.set(this, !1), i.set(this, void 0), a.set(this, void 0), c.set(this, void 0), l(this, c, new b.ConfigurationManager(e), "f"), this.config = d(this, c, "f").getConfiguration(), this.convert = (0, p.createConvertors)(this.config), l(this, n, new m.StoreManager(this.config), "f"), l(this, s, new ("ws" === this.config.getFeatures().connector ? v.WebSocketConnectionManager : g.HTTPConnectionManager)(this.config, d(this, n, "f")), "f"), (null === (t = e.features) || void 0 === t ? void 0 : t.monitorSelectedLivespinsRoom) ? l(this, a, new u.MonitorSelectedLivespinsRoomPlugin, "f") : l(this, a, h.noopPlugin, "f") } isConnected() { return d(this, s, "f").isConnected() } async Client() { return d(this, o, "f") || (l(this, i, Promise.resolve(new f.Client(d(this, n, "f"), d(this, c, "f").getConfiguration())), "f"), l(this, o, !0, "f"), await d(this, s, "f").start(), d(this, a, "f").startup()), d(this, i, "f") } async disconnect() { return d(this, a, "f").teardown(), await d(this, s, "f").stop() } async reconnect() { await d(this, s, "f").reconnect() } updateConfig(e) { d(this, c, "f").updateConfiguration(e) } } let w; n = new WeakMap, s = new WeakMap, o = new WeakMap, i = new WeakMap, a = new WeakMap, c = new WeakMap, t.sdk = e => { if (!w) { if (!e) throw Error("Cannot instantiate LivespinsSDK without configParams"); if (!e.tenant) throw Error("Cannot instantiate LivespinsSDK without tenant parameter"); w = new _(e) } return w } }, 9029: (e, t, r) => { "use strict"; Object.defineProperty(t, "__esModule", { value: !0 }); const n = r(9819), s = new class { log(e, ...t) { (0, n.sdk)().config.getDebug() && console.log(e, ...t) } }; t.default = s }, 864: function (e, t, r) { "use strict"; var n, s, o, i = this && this.__classPrivateFieldSet || function (e, t, r, n, s) { if ("m" === n) throw new TypeError("Private method is not writable"); if ("a" === n && !s) throw new TypeError("Private accessor was defined without a setter"); if ("function" == typeof t ? e !== t || !s : !t.has(e)) throw new TypeError("Cannot write private member to an object whose class did not declare it"); return "a" === n ? s.call(e, r) : s ? s.value = r : t.set(e, r), r }, a = this && this.__classPrivateFieldGet || function (e, t, r, n) { if ("a" === r && !n) throw new TypeError("Private accessor was defined without a getter"); if ("function" == typeof t ? e !== t || !n : !t.has(e)) throw new TypeError("Cannot read private member from an object whose class did not declare it"); return "m" === r ? n : "a" === r ? n.call(e) : n ? n.value : t.get(e) }, c = this && this.__importDefault || function (e) { return e && e.__esModule ? e : { default: e } }; Object.defineProperty(t, "__esModule", { value: !0 }), t.StoreManager = void 0; const l = r(5442), d = r(166), u = c(r(8611)), h = "EVENT_STREAM_ADDED", p = "EVENT_STREAM_UPDATED", g = "EVENT_SCHEDULE_UPDATED"; t.StoreManager = class { constructor(e) { n.set(this, void 0), s.set(this, void 0), o.set(this, void 0), i(this, s, { streamsById: {}, scheduledStreamsById: {}, streamersById: {}, supportedLanguagesById: {} }, "f"), i(this, n, (0, u.default)(), "f"), i(this, o, e, "f") } clear() { i(this, s, { streamsById: {}, scheduledStreamsById: {}, streamersById: {}, supportedLanguagesById: {} }, "f") } getStreams() { return Object.entries(this.getStreamsById()).map((([, e]) => e)).filter((e => !!function () { try { const e = localStorage.getItem("LS_SHOW_TESTING_STREAMS"); return Boolean(e) } catch (e) { return !1 } }() || !e.isTesting)) } getStreamsById() { return a(this, s, "f").streamsById } getScheduledStreams() { return Object.entries(this.getScheduledStreamsById()).map((([, e]) => ({ ...e, locale: a(this, o, "f").getLanguage() }))) } getScheduledStreamsById() { return a(this, s, "f").scheduledStreamsById } getStreamers() { return Object.entries(this.getStreamersById()).map((([, e]) => e)) } getStreamersById() { return a(this, s, "f").streamersById } getSupportedLanguages() { return Object.entries(this.getSupportedLanguagesById()).map((([, e]) => e)) } getSupportedLanguagesById() { return a(this, s, "f").supportedLanguagesById } clearStreams() { a(this, s, "f").streamsById = {} } clearScheduledStreams() { a(this, s, "f").scheduledStreamsById = {} } onStreamAdded(e) { a(this, n, "f").on(h, e) } onStreamUpdated(e) { a(this, n, "f").on(p, e) } onStreamDeleted(e) { a(this, n, "f").on("EVENT_STREAM_DELETED", e) } onScheduleUpdated(e) { a(this, n, "f").on(g, e) } handleStreamersMessage(e) { e.forEach((e => { a(this, s, "f").streamersById[e] = { type: "Streamer", name: e } })) } handleLanguageMessages(e) { "Languages" === e.type && (a(this, s, "f").supportedLanguagesById = Object.entries(e.message.list).reduce(((e, [, t]) => (e[t.alpha2] = t, e)), {}), a(this, n, "f").emit(g)) } handleLivespinsMessage(e) { switch (e.type) { case "StreamerSessionCreated": { const t = (0, d.streamMapper)(e), r = !a(this, s, "f").streamsById[t.sessionId]; a(this, s, "f").streamsById[t.sessionId] = t, r && a(this, n, "f").emit(h, t); break } case "StreamerSessionUpdated": case "StreamerSessionUpdatedThrottled": { if (2 === e.message.status) return delete a(this, s, "f").streamsById[e.message.sessionId], void a(this, n, "f").emit(p, e.message.sessionId); const t = (0, d.streamMapper)(e), r = a(this, s, "f").streamsById[t.sessionId]; if (JSON.stringify(t) === JSON.stringify(r)) return; a(this, s, "f").streamsById[t.sessionId] = t, a(this, n, "f").emit(p, t); break } case "StreamerSessionStopped": delete a(this, s, "f").streamsById[e.message.sessionId], a(this, n, "f").emit(p, e.message.sessionId); break; case "PrimitiveScheduleUpdated": { const t = (0, l.primitiveScheduleMapper)(e); a(this, s, "f").scheduledStreamsById = t.reduce(((e, t) => (e[t.id] = t, e)), {}), a(this, n, "f").emit(g); break } } } }, n = new WeakMap, s = new WeakMap, o = new WeakMap }, 9488: function (e, t, r) { "use strict"; var n, s, o, i, a = this && this.__classPrivateFieldSet || function (e, t, r, n, s) { if ("m" === n) throw new TypeError("Private method is not writable"); if ("a" === n && !s) throw new TypeError("Private accessor was defined without a setter"); if ("function" == typeof t ? e !== t || !s : !t.has(e)) throw new TypeError("Cannot write private member to an object whose class did not declare it"); return "a" === n ? s.call(e, r) : s ? s.value = r : t.set(e, r), r }, c = this && this.__classPrivateFieldGet || function (e, t, r, n) { if ("a" === r && !n) throw new TypeError("Private accessor was defined without a getter"); if ("function" == typeof t ? e !== t || !n : !t.has(e)) throw new TypeError("Cannot read private member from an object whose class did not declare it"); return "m" === r ? n : "a" === r ? n.call(e) : n ? n.value : t.get(e) }, l = this && this.__importDefault || function (e) { return e && e.__esModule ? e : { default: e } }; Object.defineProperty(t, "__esModule", { value: !0 }), t.WebSocketConnectionManager = void 0; const d = l(r(9029)), u = r(1040); t.WebSocketConnectionManager = class { constructor(e, t) { n.set(this, void 0), s.set(this, void 0), o.set(this, void 0), i.set(this, void 0), a(this, i, e, "f"), a(this, o, t, "f"), a(this, n, (0, u.createConnection)(e.getServerConfig()), "f"), a(this, s, [], "f") } async stop() { await c(this, n, "f").stop() } async start() { await c(this, n, "f").start(), this.on("livespins", c(this, o, "f").handleLivespinsMessage.bind(c(this, o, "f"))), this.on("languages", c(this, o, "f").handleLanguageMessages.bind(c(this, o, "f"))), await Promise.all([this.subscribe("livespins/streamerSessionsThrottled", { payload: { tenantId: c(this, i, "f").getTenant() } }), this.subscribe("livespins/primitive-schedule", { payload: { tenantId: c(this, i, "f").getTenant() } }), this.subscribe("languages")]), c(this, n, "f").onclose((e => { e && this.reconnect({ startConnection: !0 }) })), c(this, n, "f").onreconnected((() => { this.reconnect({ startConnection: !1 }) })) } async reconnect({ startConnection: e } = { startConnection: !0 }) { e && await this.start(), this.resubscribe() } isConnected() { return "Connected" === c(this, n, "f").state } async subscribe(e, t = {}, r = !0) { const o = () => (d.default.log("Subscribing with", { topic: e, extraParams: t }), c(this, n, "f").invoke("Subscribe", { ...t, topic: e })); return r && c(this, s, "f").push([e, o]), await o() } on(e, t) { c(this, n, "f").on(e, t) } off(e) { a(this, s, c(this, s, "f").filter((([t]) => e !== t)), "f"), c(this, n, "f").off(e) } async resubscribe() { await Promise.all(c(this, s, "f").map((([, e]) => e(c(this, n, "f"))))) } }, n = new WeakMap, s = new WeakMap, o = new WeakMap, i = new WeakMap }, 8763: function (e, t) { "use strict"; var r, n, s, o, i, a = this && this.__classPrivateFieldSet || function (e, t, r, n, s) { if ("m" === n) throw new TypeError("Private method is not writable"); if ("a" === n && !s) throw new TypeError("Private accessor was defined without a setter"); if ("function" == typeof t ? e !== t || !s : !t.has(e)) throw new TypeError("Cannot write private member to an object whose class did not declare it"); return "a" === n ? s.call(e, r) : s ? s.value = r : t.set(e, r), r }, c = this && this.__classPrivateFieldGet || function (e, t, r, n) { if ("a" === r && !n) throw new TypeError("Private accessor was defined without a getter"); if ("function" == typeof t ? e !== t || !n : !t.has(e)) throw new TypeError("Cannot read private member from an object whose class did not declare it"); return "m" === r ? n : "a" === r ? n.call(e) : n ? n.value : t.get(e) }; function l(e = {}) { return { api: e.api || "https://api.eu1.livespins.cloud/stream", ui: e.ui || "https://play.livespins.com" } } Object.defineProperty(t, "__esModule", { value: !0 }), t.ConfigurationManager = t.createServerConfiguration = void 0, t.createServerConfiguration = l, t.ConfigurationManager = class { constructor(e) { r.set(this, void 0), n.set(this, void 0), s.set(this, void 0), o.set(this, void 0), i.set(this, void 0), a(this, r, e.tenant, "f"), a(this, n, l(e.serverConfig), "f"), a(this, o, e.language || "en", "f"), a(this, s, e.features || {}, "f"), a(this, i, e.debug || !1, "f") } getConfiguration() { return { getServerConfig: () => c(this, n, "f"), getTenant: () => c(this, r, "f"), getLanguage: () => c(this, o, "f"), getFeatures: () => c(this, s, "f"), getDebug: () => c(this, i, "f") } } updateConfiguration(e) { null != e.debug && a(this, i, e.debug, "f"), null != e.language && a(this, o, e.language, "f") } }, r = new WeakMap, n = new WeakMap, s = new WeakMap, o = new WeakMap, i = new WeakMap }, 1040: (e, t, r) => { "use strict"; Object.defineProperty(t, "__esModule", { value: !0 }), t.createConnection = void 0; const n = r(5660); t.createConnection = e => (new n.HubConnectionBuilder).withAutomaticReconnect().withUrl(e.api).build() }, 5442: function (e, t, r) { "use strict"; var n = this && this.__importDefault || function (e) { return e && e.__esModule ? e : { default: e } }; Object.defineProperty(t, "__esModule", { value: !0 }), t.primitiveScheduleMapper = void 0; const s = r(890), o = r(5005), i = r(4882), a = n(r(7322)), c = ({ language: e, streamerId: t, timestamp: r }) => [e, t, r].join("-"); t.primitiveScheduleMapper = e => e.message.map((e => { const t = (0, a.default)(e.startTime), r = (0, i.getStreamerImageFileName)(e.streamerId), n = r ? (0, s.streamerPortraitImageURL)(r) : null, l = r ? (0, s.streamerNameImageURL)(r) : null; let d = null; e.metadata && e.metadata.EventImageFileName && (d = (0, o.buildEventImageURL)(e.metadata.EventImageFileName)); let u = null; e.metadata && e.metadata.EventColor && (u = e.metadata.EventColor); const h = { type: "ScheduledStream", id: c({ language: e.language, streamerId: e.streamerId, timestamp: t.unix() }), scheduledStartTime: t.unix(), time: t.format("HH:mm"), streamer: e.streamer, streamerNickname: e.streamer, streamerId: e.streamerId, language: e.language, locale: "", date: t.toString(), metadata: JSON.stringify({ eventColor: e.metadata.EventColor, eventFileName: e.metadata.EventImageFileName }), streamerImage: n, streamerNameImage: l, streamEventImage: d, streamEventAccentColor: u }; return Object.assign({}, h, e.metadata.EventColor && e.metadata.EventImageFileName && { metadata: JSON.stringify({ eventColor: e.metadata.EventColor, eventFileName: e.metadata.EventImageFileName }) }) })).filter((e => (0, a.default)(e.date).isAfter((0, a.default)()))).sort(((e, t) => (0, a.default)(e.date).diff((0, a.default)(t.date)))) }, 166: function (e, t, r) { "use strict"; var n = this && this.__importDefault || function (e) { return e && e.__esModule ? e : { default: e } }; Object.defineProperty(t, "__esModule", { value: !0 }), t.streamMapper = void 0; const s = r(890), o = r(5005), i = r(4882), a = n(r(7322)); t.streamMapper = function (e) { const t = (0, a.default)(e.message.startDate), r = e.message.streamerId, n = (0, i.getStreamerImageFileName)(r), c = n ? (0, s.streamerPortraitImageURL)(n) : null, l = n ? (0, s.streamerNameImageURL)(n) : null, d = JSON.stringify(e.message.metadata); let u = null; e.message.metadata && e.message.metadata.eventFileName && (u = (0, o.buildEventImageURL)(e.message.metadata.eventFileName)); let h = null; return e.message.metadata && e.message.metadata.eventColor && (h = e.message.metadata.eventColor), { type: "Stream", streamerId: r, sessionId: e.message.sessionId, streamerNickname: e.message.streamerNickname, maxPlayers: e.message.maxPlayers, totalPlayersInBetBehind: e.message.betBehindStats.totalPlayersInBetBehind, language: e.message.language, startTimestamp: t.unix(), viewers: e.message.authenticatedViewers + e.message.anonymousViewers, currentGame: e.message.currentGame, currentGameTitle: e.message.currentGameTitle, accountId: e.message.millicastLiveStreamDetails.accountId, streamerStreamId: e.message.millicastLiveStreamDetails.streamerStreamId, gameStreamId: e.message.millicastLiveStreamDetails.gameStreamId, isSingleStream: e.message.isSingleStream, name: e.message.name, description: e.message.description, order: e.message.order, isTesting: e.message.isTesting, metadata: d, "content-language": "", locale: "", thumbnail: `https://thumbnails.livespins.com/streams/${e.message.sessionId}.jpg`, streamerImage: c, streamerNameImage: l, streamEventImage: u, streamEventAccentColor: h } } }, 2498: (e, t) => { "use strict"; Object.defineProperty(t, "__esModule", { value: !0 }), t.generateLobbyURLFactory = t.generatePlayURLFactory = void 0, t.generatePlayURLFactory = e => t => { const r = new URLSearchParams; return r.set("authToken", t.authToken), t.tenantId ? r.set("tenantId", t.tenantId) : r.set("tenantId", e.getTenant()), t.language ? r.set("language", t.language) : r.set("language", e.getLanguage()), t.backURL && r.set("backURL", t.backURL), t.shareURL && r.set("shareURL", t.shareURL), t.streamEndRedirect && r.set("streamEndRedirect", Boolean(t.streamEndRedirect).toString()), `${e.getServerConfig().ui}/session/${t.sessionId}?${r.toString()}` }, t.generateLobbyURLFactory = e => t => { const r = new URLSearchParams; return t.authToken && r.set("authToken", t.authToken), t.tenantId ? r.set("tenantId", t.tenantId) : r.set("tenantId", e.getTenant()), t.language ? r.set("language", t.language) : r.set("language", e.getLanguage()), t.backURL && r.set("backURL", t.backURL), t.shareURL && r.set("shareURL", t.shareURL), t.streamEndRedirect && r.set("streamEndRedirect", Boolean(t.streamEndRedirect).toString()), t.openStream && r.set("openStream", String(t.openStream).toString()), `${e.getServerConfig().ui}/lobby/?${r.toString()}` } }, 1904: function (e, t, r) { "use strict"; var n = this && this.__importDefault || function (e) { return e && e.__esModule ? e : { default: e } }; Object.defineProperty(t, "__esModule", { value: !0 }), t.loadLanguageData = void 0; const s = n(r(954)), o = n(r(532)), i = n(r(1005)), a = n(r(3458)), c = n(r(9554)), l = n(r(1822)), d = n(r(1621)), u = n(r(3838)), h = n(r(5723)), p = n(r(3355)), g = n(r(316)), f = n(r(5726)), m = n(r(6709)), v = n(r(20)), b = n(r(8809)), _ = n(r(6734)), w = n(r(8923)), y = n(r(3821)), S = n(r(7073)); t.loadLanguageData = function (e) { try { switch (e = e.toLowerCase()) { case "bg": return s.default; case "de": return o.default; case "en": default: return i.default; case "es": return a.default; case "fi": return c.default; case "fr": return l.default; case "hu": return d.default; case "id": return u.default; case "ja": return h.default; case "ko": return p.default; case "no": return g.default; case "pl": return f.default; case "pt": return m.default; case "ro": return v.default; case "ru": return b.default; case "th": return _.default; case "tr": return w.default; case "vi": return y.default; case "zh": return S.default } } catch (e) { return i.default } } }, 3607: function (e, t, r) { "use strict"; var n = this && this.__createBinding || (Object.create ? function (e, t, r, n) { void 0 === n && (n = r); var s = Object.getOwnPropertyDescriptor(t, r); s && !("get" in s ? !t.__esModule : s.writable || s.configurable) || (s = { enumerable: !0, get: function () { return t[r] } }), Object.defineProperty(e, n, s) } : function (e, t, r, n) { void 0 === n && (n = r), e[n] = t[r] }), s = this && this.__exportStar || function (e, t) { for (var r in e) "default" === r || Object.prototype.hasOwnProperty.call(t, r) || n(t, e, r) }, o = this && this.__importDefault || function (e) { return e && e.__esModule ? e : { default: e } }; Object.defineProperty(t, "__esModule", { value: !0 }), r(9758), r(7265), r(4494); const i = o(r(7322)), a = o(r(7060)), c = o(r(3954)); i.default.extend(c.default), i.default.extend(a.default), s(r(9819), t) }, 1230: function (e, t) { "use strict"; Object.defineProperty(t, "__esModule", { value: !0 }), t.debounce = void 0, t.debounce = (e, t = 300) => { let r; return (...n) => { clearTimeout(r), r = setTimeout((() => { e.apply(this, n) }), t) } } }, 475: (e, t) => { "use strict"; Object.defineProperty(t, "__esModule", { value: !0 }), t.tryCatch = void 0, t.tryCatch = function (e, t) { try { return e() } catch (e) { return t() } } }, 6771: () => { }, 8022: () => { }, 6045: () => { }, 8190: () => { }, 7333: () => { }, 6139: () => { }, 8593: e => { "use strict"; e.exports = JSON.parse('{"name":"axios","version":"0.21.4","description":"Promise based HTTP client for the browser and node.js","main":"index.js","scripts":{"test":"grunt test","start":"node ./sandbox/server.js","build":"NODE_ENV=production grunt build","preversion":"npm test","version":"npm run build && grunt version && git add -A dist && git add CHANGELOG.md bower.json package.json","postversion":"git push && git push --tags","examples":"node ./examples/server.js","coveralls":"cat coverage/lcov.info | ./node_modules/coveralls/bin/coveralls.js","fix":"eslint --fix lib/**/*.js"},"repository":{"type":"git","url":"https://github.com/axios/axios.git"},"keywords":["xhr","http","ajax","promise","node"],"author":"Matt Zabriskie","license":"MIT","bugs":{"url":"https://github.com/axios/axios/issues"},"homepage":"https://axios-http.com","devDependencies":{"coveralls":"^3.0.0","es6-promise":"^4.2.4","grunt":"^1.3.0","grunt-banner":"^0.6.0","grunt-cli":"^1.2.0","grunt-contrib-clean":"^1.1.0","grunt-contrib-watch":"^1.0.0","grunt-eslint":"^23.0.0","grunt-karma":"^4.0.0","grunt-mocha-test":"^0.13.3","grunt-ts":"^6.0.0-beta.19","grunt-webpack":"^4.0.2","istanbul-instrumenter-loader":"^1.0.0","jasmine-core":"^2.4.1","karma":"^6.3.2","karma-chrome-launcher":"^3.1.0","karma-firefox-launcher":"^2.1.0","karma-jasmine":"^1.1.1","karma-jasmine-ajax":"^0.1.13","karma-safari-launcher":"^1.0.0","karma-sauce-launcher":"^4.3.6","karma-sinon":"^1.0.5","karma-sourcemap-loader":"^0.3.8","karma-webpack":"^4.0.2","load-grunt-tasks":"^3.5.2","minimist":"^1.2.0","mocha":"^8.2.1","sinon":"^4.5.0","terser-webpack-plugin":"^4.2.3","typescript":"^4.0.5","url-search-params":"^0.10.0","webpack":"^4.44.2","webpack-dev-server":"^3.11.0"},"browser":{"./lib/adapters/http.js":"./lib/adapters/xhr.js"},"jsdelivr":"dist/axios.min.js","unpkg":"dist/axios.min.js","typings":"./index.d.ts","dependencies":{"follow-redirects":"^1.14.0"},"bundlesize":[{"path":"./dist/axios.min.js","threshold":"5kB"}]}') }, 954: e => { "use strict"; e.exports = JSON.parse('{"at":"","in_x_minutes":" {number} ","later":"-","live":" ","now":"","play_now":" ","playing":"","starts":"","test":"","tomorrow":"","up_next":""}') }, 532: e => { "use strict"; e.exports = JSON.parse('{"at":"bei","in_x_minutes":"in {number} Minuten","later":"Spter","live":"Live","now":"jetzt","play_now":"Jetzt spielen","playing":"Spielen","starts":"Startet","test":"Test","tomorrow":"morgen","up_next":"Als nchstes"}') }, 1005: e => { "use strict"; e.exports = JSON.parse('{"at":"at","in_x_minutes":"in {number} minutes","later":"Later","live":"Live","now":"now","play_now":"Play Now","playing":"Playing","starts":"Starts","test":"Test","tomorrow":"tomorrow","up_next":"Up Next"}') }, 3458: e => { "use strict"; e.exports = JSON.parse('{"at":"en","in_x_minutes":"en {number} minutos","later":"Ms tarde","live":"En directo","now":"ahora","play_now":"Jugar ahora","playing":"Jugando a","starts":"Inicia","test":"Prueba","tomorrow":"maana","up_next":"A continuacin"}') }, 9554: e => { "use strict"; e.exports = JSON.parse('{"at":"osoitteessa","in_x_minutes":"{number} minuutissa","later":"Myhemmin","live":"Live","now":"nyt","play_now":"Pelaa nyt","playing":"Pelaaminen","starts":"Alkaa","test":"Testi","tomorrow":"huomenna","up_next":"Seuraavaksi"}') }, 1822: e => { "use strict"; e.exports = JSON.parse('{"at":" ","in_x_minutes":"dans {number} minutes","later":"Plus tard","live":"En Direct","now":"maintenant","play_now":"Jouer maintenant","playing":"Jouer  ","starts":"Commence","test":"Test","tomorrow":"demain","up_next":"Suivant"}') }, 1621: e => { "use strict"; e.exports = JSON.parse('{"at":"a  cmen.","in_x_minutes":"{number} percben","later":"Ksbb","live":"l","now":"most","play_now":"Jtsszon most","playing":"Jtk","starts":"Indul","test":"Teszt","tomorrow":"holnap","up_next":"Kvetkez"}') }, 3838: e => { "use strict"; e.exports = JSON.parse('{"at":"di","in_x_minutes":"dalam {number} menit","later":"Kemudian","live":"Hidup","now":"sekarang","play_now":"Main sekarang","playing":"Bermain","starts":"Mulai","test":"Tes","tomorrow":"besok","up_next":"Berikutnya"}') }, 5723: e => { "use strict"; e.exports = JSON.parse('{"at":"","in_x_minutes":"{number} ","later":"","live":"","now":"","play_now":"","playing":"","starts":"","test":"","tomorrow":"","up_next":""}') }, 3355: e => { "use strict"; e.exports = JSON.parse('{"at":"","in_x_minutes":"{number}  ","later":"","live":"","now":"","play_now":"  ","playing":"","starts":"","test":"","tomorrow":"","up_next":""}') }, 316: e => { "use strict"; e.exports = JSON.parse('{"at":"kl.","in_x_minutes":"p {number} minutter","later":"Seinere","live":"Bo","now":"n","play_now":"Spill n","playing":"Spiller","starts":"Starter","test":"Test","tomorrow":"morgen","up_next":"Neste"}') }, 5726: e => { "use strict"; e.exports = JSON.parse('{"at":"na","in_x_minutes":"w {number} minut","later":"Pniej","live":"Live","now":"teraz","play_now":"Zagraj teraz","playing":"Grajc w","starts":"Rozpoczyna si","test":"Test","tomorrow":"jutro","up_next":"Do nastpnego"}') }, 6709: e => { "use strict"; e.exports = JSON.parse('{"at":"em","in_x_minutes":"em {number} minutos","later":"Mais tarde","live":"Ao Vivo","now":"agora","play_now":"Joga J","playing":"A jogar","starts":"Comea em","test":"Teste","tomorrow":"amanh","up_next":"A Seguir"}') }, 20: e => { "use strict"; e.exports = JSON.parse('{"at":"la","in_x_minutes":"n {number} minute","later":"Mai trziu","live":"Live","now":"acum","play_now":"Joac acum","playing":"Se joac","starts":"ncepe","test":"Test","tomorrow":"mine","up_next":"n continuare"}') }, 8809: e => { "use strict"; e.exports = JSON.parse('{"at":"","in_x_minutes":" {number} ","later":"","live":" ","now":"","play_now":" ","playing":"","starts":"","test":"","tomorrow":"","up_next":""}') }, 6734: e => { "use strict"; e.exports = JSON.parse('{"at":"","in_x_minutes":"  {number} ","later":" ","live":"","now":"","play_now":"","playing":"","starts":"","test":"","tomorrow":"","up_next":""}') }, 8923: e => { "use strict"; e.exports = JSON.parse('{"at":"a","in_x_minutes":"{number} dakika iinde","later":"Daha sonra","live":"Canl","now":"imdi","play_now":"Hemen Oyna","playing":"Oynanyor","starts":"Balang:","test":"Test","tomorrow":"yarn","up_next":"Bir sonraki"}') }, 3821: e => { "use strict"; e.exports = JSON.parse('{"at":"lc","in_x_minutes":"trong {number} pht","later":"Sau ","live":"Sng","now":"by gi","play_now":"Bt u chi","playing":"ang chi","starts":"bt u","test":"B i kim tra","tomorrow":"Ng y mai","up_next":"Tip theo"}') }, 7073: e => { "use strict"; e.exports = JSON.parse('{"at":"","in_x_minutes":"{number} ","later":"","live":"","now":"","play_now":"","playing":"","starts":"","test":"","tomorrow":"","up_next":""}') } }, t = {}; function r(n) { var s = t[n]; if (void 0 !== s) return s.exports; var o = t[n] = { exports: {} }; return e[n].call(o.exports, o, o.exports, r), o.exports } return r.d = (e, t) => { for (var n in t) r.o(t, n) && !r.o(e, n) && Object.defineProperty(e, n, { enumerable: !0, get: t[n] }) }, r.g = function () { if ("object" == typeof globalThis) return globalThis; try { return this || new Function("return this")() } catch (e) { if ("object" == typeof window) return window } }(), r.o = (e, t) => Object.prototype.hasOwnProperty.call(e, t), r.r = e => { "undefined" != typeof Symbol && Symbol.toStringTag && Object.defineProperty(e, Symbol.toStringTag, { value: "Module" }), Object.defineProperty(e, "__esModule", { value: !0 }) }, r(3607) })()));